{
    "docs": [
        {
            "location": "/", 
            "text": "Localization library for \nReact\n/\nRedux\n.\n\n\n\n\n\n  \n\n  \n\n\n\n\n\nInstallation\n\n\nnpm install react-localize-redux --save\n\n\n\n\n\n\nNot using React 16?\n\n\nIf you are using an older version of react, and plan on using the \nTranslate\n component\nyou have the following options:\n\n\n\n\n\n\nUpdate react to a version \n 16 as \nTranslate\n requires the ability to render \nfragments and strings\n (\nrecommended\n).\n\n\n\n\n\n\nUsing Translate component with React 15\n\n\n\n\n\n\n\n\nArticles\n\n\n\n\nDead simple localization for your React components\n\n\nMigrating from v1 to v2?", 
            "title": "Home"
        }, 
        {
            "location": "/#installation", 
            "text": "npm install react-localize-redux --save", 
            "title": "Installation"
        }, 
        {
            "location": "/#not-using-react-16", 
            "text": "If you are using an older version of react, and plan on using the  Translate  component\nyou have the following options:    Update react to a version   16 as  Translate  requires the ability to render  fragments and strings  ( recommended ).    Using Translate component with React 15", 
            "title": "Not using React 16?"
        }, 
        {
            "location": "/#articles", 
            "text": "Dead simple localization for your React components  Migrating from v1 to v2?", 
            "title": "Articles"
        }, 
        {
            "location": "/getting-started/", 
            "text": "1. Add reducer\n\n\n\n  \nNote\n\n  \nBy default \nreact-localize-redux\n assumes the reducer is mounted under the \nlocale\n key. TODO: ... instruct on how to add custom slice for Translate\n\n\n\n\n\nimport { createStore, combineReducers } from 'redux';\nimport { user } from './reducers';\nimport { localeReducer as locale } from 'react-localize-redux';\n\nconst store = createStore(combineReducers({ user, locale }));\n\nconst App = props =\n {\n  return (\n    \nProvider store={ store }\n\n      ...\n    \n/Provider\n\n  );\n};\n\n\n\n\n\n\n2. Initialize languages\n\n\nDispatch \ninitialize\n action creator with the languages you wish to support. By default the first language in the array will be set as the active language.\n\n\n\n  \nNote\n\n  \nEnsure you dispatch \ninitialize\n before mounting any components that need translations. For example in your root component's \nconstructor\n.\n\n\n\n\n\nimport { initialize } from 'react-localize-redux';\n\nconst languages = ['en', 'fr', 'es'];\nstore.dispatch(initialize(languages));\n\n\n\n\nTo set a different default active language set the \ndefaultLanguage\n option.\n\n\nconst languages = ['en', 'fr', 'es'];\nstore.dispatch(initialize(languages, { defaultLanguage: 'fr' }));\n\n\n\n\nIf you want to associate a language name with each language code you can use the following format:\n\n\nconst languages = [\n  { name: 'English', code: 'en' },\n  { name: 'French', code: 'fr' },\n  { name: 'Spanish', code: 'es' }\n];\nstore.dispatch(initialize(languages));\n\n\n\n\n\n\n3. Add translation data\n\n\nTypically you will store your translation data in json files, but the data can also be a vanilla JS object. \n\n\nIn order to add translation data to your application there are two action creators available - \naddTranslation\n and \naddTranslationForLanguage\n. Which one you use will depend on which format your translation data is in - see \nformatting translation data\n for more information.\n\n\n Multiple language format \n\n\nimport { addTranslation } from 'react-localize-redux';\n\nconst translations = {\n  greeting: ['Hello', 'Bonjour', 'Hola'],\n  farewell: ['Goodbye', 'Au revoir', 'Adi\u00f3s']\n};\n\nstore.dispatch(addTranslation(translations));\n\n\n\n\n Single language format \n\n\nimport { addTranslationForLanguage } from 'react-localize-redux';\n\nconst english = {\n  greeting: 'Hello',\n  farewell: 'Goodbye'\n};\n\nconst json = require('en.json');\nstore.dispatch(addTranslationForLanguage(english, 'en'));\n\n\n\n\n\n\n4. Add translations to components\n\n\nOnce you've added your translation data you'll need a way to get it into your components. That is where the \nTranslate\n component comes in and it comes in a couple different flavours.\n\n\n Flavour 1 \n\n\nThe \nid\n prop should match the key of the translation data you want to insert. Any copy added as Translate's \nchildren\n will automatically be added to your translation data for that key under the default language. \n\n\nimport { Translate } from 'react-localize-redux';\n\nconst Greeting = props =\n (\n  \nh1\nTranslate id=\ngreeting\nHello\n/Translate\n/h1\n\n);\n\n\n\n\nYou can include HTML markup as \nchildren\n, but ensure you include the same markup in your translation data. Since the default language's translation will automatically be pulled from Translate's \nchildren\n you can set it to \nnull\n.\n\n\nimport { Translate } from 'react-localize-redux';\n\nconst translations = {\n  food: [\n    null,\n    '\nul\nli\nLait\n/li\nli\nbiscuits\n/li\n/ul\n'\n  ]\n};\n\nconst Foods = props =\n (\n  \nTranslate id=\nfood\n\n    \nul\n\n      \nli\nMilk\n/li\n\n      \nli\nCookies\n/li\n\n    \n/ul\n\n  \n/Translate\n\n);\n\n\n\n\nYou can insert translations with placeholder's for dynamic data.\n\n\nimport { Translate } from 'react-localize-redux';\n\nconst Profile = props =\n (\n  \nTranslate id=\nprofile\n data={{ name: 'Ted', date: new Date() }}\n\n    {'User: ${name} last login ${date}'}\n  \n/Translate\n\n);\n\n\n\n\n\n\n Flavour 2 - render prop function \n\n\nYou can also pass Translate a function as it's child that returns the elements you want to render. This function is commonly referred to as a \nrender prop function\n, and is called with the following arguments:\n\n\n\n\n\n\n\n\nname\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntranslate\n\n\nSame as value returned from \ngetTranslate\n selector.\n\n\n\n\n\n\nactiveLanguage\n\n\nSame as value returned from \ngetActiveLanguage\n selector.\n\n\n\n\n\n\nlanguages\n\n\nSame as value returned from \ngetLanguages\n selector.\n\n\n\n\n\n\n\n\nimport { Translate } from 'react-localize-redux';\n\nconst LanguageSelector = props =\n (\n  \nTranslate\n\n    {(translate, activeLanguage, languages) =\n\n      \ndiv\n\n        \nh2\n{ translate('heading') } - ({ activeLanguage.code })\n/h2\n\n        \nul\n\n          {languages.map(languge =\n\n            \nli\n\n              \na href={`/${language.code}`}\n{ language.name }\n/a\n\n            \n/li\n\n          )}\n        \n/ul\n\n      \n/div\n\n    }\n  \n/Translate\n\n);\n\n\n\n\n\n\n You can also access the translate function directly in connected components \n\n\nIf you have a component that is already using \nconnect\n use \ngetTranslate\n in your \nmapStateToProps\n to add the \ntranslate\n function to your component's props.\n\n\nimport { getTranslate, getActiveLanguage } from 'react-localize-redux';\n\nconst Greeting = ({ translate, currentLanguage }) =\n (\n  \ndiv\n\n    \nh1\n{ translate('greeting') }\n/h1\n\n    \nbutton\n{ translate('farewell') }\n/button\n\n  \n/div\n\n);\n\nconst mapStateToProps = state =\n ({\n  translate: getTranslate(state.locale),\n  currentLanguage: getActiveLanguage(state.locale).code\n});\n\nexport default connect(mapStateToProps)(Greeting);\n\n\n\n\n\n\n5. Change language\n\n\nDispatch \nsetActiveLanguage\n and pass the language.\n\n\nimport { setActiveLanguage } from 'react-localize-redux';\n\nstore.dispatch(setActiveLanguage('fr'));", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#1-add-reducer", 
            "text": "Note \n   By default  react-localize-redux  assumes the reducer is mounted under the  locale  key. TODO: ... instruct on how to add custom slice for Translate   import { createStore, combineReducers } from 'redux';\nimport { user } from './reducers';\nimport { localeReducer as locale } from 'react-localize-redux';\n\nconst store = createStore(combineReducers({ user, locale }));\n\nconst App = props =  {\n  return (\n     Provider store={ store } \n      ...\n     /Provider \n  );\n};", 
            "title": "1. Add reducer"
        }, 
        {
            "location": "/getting-started/#2-initialize-languages", 
            "text": "Dispatch  initialize  action creator with the languages you wish to support. By default the first language in the array will be set as the active language.  \n   Note \n   Ensure you dispatch  initialize  before mounting any components that need translations. For example in your root component's  constructor .   import { initialize } from 'react-localize-redux';\n\nconst languages = ['en', 'fr', 'es'];\nstore.dispatch(initialize(languages));  To set a different default active language set the  defaultLanguage  option.  const languages = ['en', 'fr', 'es'];\nstore.dispatch(initialize(languages, { defaultLanguage: 'fr' }));  If you want to associate a language name with each language code you can use the following format:  const languages = [\n  { name: 'English', code: 'en' },\n  { name: 'French', code: 'fr' },\n  { name: 'Spanish', code: 'es' }\n];\nstore.dispatch(initialize(languages));", 
            "title": "2. Initialize languages"
        }, 
        {
            "location": "/getting-started/#3-add-translation-data", 
            "text": "Typically you will store your translation data in json files, but the data can also be a vanilla JS object.   In order to add translation data to your application there are two action creators available -  addTranslation  and  addTranslationForLanguage . Which one you use will depend on which format your translation data is in - see  formatting translation data  for more information.   Multiple language format   import { addTranslation } from 'react-localize-redux';\n\nconst translations = {\n  greeting: ['Hello', 'Bonjour', 'Hola'],\n  farewell: ['Goodbye', 'Au revoir', 'Adi\u00f3s']\n};\n\nstore.dispatch(addTranslation(translations));   Single language format   import { addTranslationForLanguage } from 'react-localize-redux';\n\nconst english = {\n  greeting: 'Hello',\n  farewell: 'Goodbye'\n};\n\nconst json = require('en.json');\nstore.dispatch(addTranslationForLanguage(english, 'en'));", 
            "title": "3. Add translation data"
        }, 
        {
            "location": "/getting-started/#4-add-translations-to-components", 
            "text": "Once you've added your translation data you'll need a way to get it into your components. That is where the  Translate  component comes in and it comes in a couple different flavours.   Flavour 1   The  id  prop should match the key of the translation data you want to insert. Any copy added as Translate's  children  will automatically be added to your translation data for that key under the default language.   import { Translate } from 'react-localize-redux';\n\nconst Greeting = props =  (\n   h1 Translate id= greeting Hello /Translate /h1 \n);  You can include HTML markup as  children , but ensure you include the same markup in your translation data. Since the default language's translation will automatically be pulled from Translate's  children  you can set it to  null .  import { Translate } from 'react-localize-redux';\n\nconst translations = {\n  food: [\n    null,\n    ' ul li Lait /li li biscuits /li /ul '\n  ]\n};\n\nconst Foods = props =  (\n   Translate id= food \n     ul \n       li Milk /li \n       li Cookies /li \n     /ul \n   /Translate \n);  You can insert translations with placeholder's for dynamic data.  import { Translate } from 'react-localize-redux';\n\nconst Profile = props =  (\n   Translate id= profile  data={{ name: 'Ted', date: new Date() }} \n    {'User: ${name} last login ${date}'}\n   /Translate \n);    Flavour 2 - render prop function   You can also pass Translate a function as it's child that returns the elements you want to render. This function is commonly referred to as a  render prop function , and is called with the following arguments:     name  Description      translate  Same as value returned from  getTranslate  selector.    activeLanguage  Same as value returned from  getActiveLanguage  selector.    languages  Same as value returned from  getLanguages  selector.     import { Translate } from 'react-localize-redux';\n\nconst LanguageSelector = props =  (\n   Translate \n    {(translate, activeLanguage, languages) = \n       div \n         h2 { translate('heading') } - ({ activeLanguage.code }) /h2 \n         ul \n          {languages.map(languge = \n             li \n               a href={`/${language.code}`} { language.name } /a \n             /li \n          )}\n         /ul \n       /div \n    }\n   /Translate \n);    You can also access the translate function directly in connected components   If you have a component that is already using  connect  use  getTranslate  in your  mapStateToProps  to add the  translate  function to your component's props.  import { getTranslate, getActiveLanguage } from 'react-localize-redux';\n\nconst Greeting = ({ translate, currentLanguage }) =  (\n   div \n     h1 { translate('greeting') } /h1 \n     button { translate('farewell') } /button \n   /div \n);\n\nconst mapStateToProps = state =  ({\n  translate: getTranslate(state.locale),\n  currentLanguage: getActiveLanguage(state.locale).code\n});\n\nexport default connect(mapStateToProps)(Greeting);", 
            "title": "4. Add translations to components"
        }, 
        {
            "location": "/getting-started/#5-change-language", 
            "text": "Dispatch  setActiveLanguage  and pass the language.  import { setActiveLanguage } from 'react-localize-redux';\n\nstore.dispatch(setActiveLanguage('fr'));", 
            "title": "5. Change language"
        }, 
        {
            "location": "/formatting-translation-data/", 
            "text": "The translation data for you application will either come from json or vanilla JS, but in order for \nreact-localize-redux\n to work with your data in needs to be in one of the following formats.\n\n\nMultiple language format\n\n\n\n\nUse \naddTranslation\n to add data in this format.\n\n\n\n\nThe data is an object where the property name is your translation key, and the value is an array of translations. The translation key is used to identify the translation, and the value is an array that enforces the following...\n\n\n\n\nIncludes a translation for each language your app supports.\n\n\nThe order of the translation strings in the array matters! The order \nMUST\n follow the order of the languages array passed to \nsetLanguages\n.\n\n\n\n\nAssuming your application has dispatched \nsetLanguages('en', 'fr', 'es')\n:\n\n\n{\n  \ngreeting\n: [\n    \nHello\n,      (en)\n    \nBonjour\n,    (fr)\n    \nHola\n,       (es)\n  ],\n  \nfarewell\n: [\n    \nGoodbye\n,    (en)\n    \nAu revoir\n,  (fr)\n    \nAdi\u00f3s\n       (es)\n  ]\n}\n\n\n\n\n\n\nSingle language format\n\n\n\n\nUse \naddTranslationForLanguage\n to add data in this format.\n\n\n\n\nThe data is an object where the property name is your translation key, and the value is the translation for the language. With the single language format you would dispatch \naddTranslationForLanguage\n for each language you support.\n\n\nAssuming your application \nsetLanguages('en', 'fr', 'es')\n:\n\n\n// en.json\n{\n  \ngreeting\n: \nHello\n,\n  \nfarewell\n: \nGoodbye\n\n}\n\n// fr.json\n{\n  \ngreeting\n:\nBonjour\n,\n  \nfarewell\n: \nAu revoir\n\n}\n\n// es.json\n{\n  \ngreeting\n: \nHola\n,\n  \nfarewell\n: \nAdi\u00f3s\n\n}\n\n\n\n\n\n\nCustom data format\n\n\nIf you cannot use the supported data formats there is a way to instruct react-localize-redux on how to handle your custom data. To do this you must pass the \ntranslationTransform\n option when dispatching the \nintialize\n action, which takes a function in the following format: \n\n\nconst transformationFunction = (translationData: Object, languagesCodes: string[]) =\n {\n  // Your transformation logic goes here...\n};\n\n\n\n\nThis function is responsible for taking your custom data, and transforming it into the format required by react-localize-redux. You are responsible for writing the transformation logic, but after that the function will be run automatically whenever dispatching \naddTranslation\n.\n\n\n\n  \nNote\n\n  \nThe transformation function will not be run if you use the \naddTranslationForLanguage\n action.\n\n\n\n\n\n Example \n\n\nFor example if you had data in the following format that you wanted to use...\n\n\nconst customTranslation = {\n  en: {\n    title: 'Title',\n    subtitle: 'Subtitle'\n  },\n  fr: {\n    title: 'FR - Title',\n    subtitle: 'FR - Subtitle'\n  }\n};\n\n\n\n\nYou would need to transform it into this format to work with react-localize-redux.\n\n\nconst translations = {\n  title: ['Title', 'FR - Title'],\n  subtitle: ['Subtitle', 'FR - Subtitle']\n};\n\n\n\n\nThis is where the transformation function comes in - we need to write a function that takes the custom translationData and returns the react-localize-redux format. Here is an example of what that function could look like for the example custom data:\n\n\nconst transformFunction = (translationData, languageCodes) =\n {\n  return Object.keys(translationData).reduce((prev, cur, index) =\n {\n    const languageData = data[cur];\n\n    for(let prop in languageData) {\n      const values = prev[prop] || [];\n      prev[prop] = languageCodes.map((code, languageIndex) =\n {\n        return index === languageIndex\n          ? languageData[prop]\n          : values[languageIndex];\n      })\n    }\n\n    return prev;\n  }, {});\n};\n\n\n\n\nNow when you dispatch the \nintialize\n action make sure you set the \ntranslationTransform\n option equal to the \ntransformFunction\n. Now anytime you dispatch the \naddTranslation\n action the \ntransformFunction\n will run on the translation data you are adding.\n\n\nconst languages = ['en', 'fr'];\nstore.dispatch(initialize(languages, { translationTransform: transformFunction }));\n\nstore.dispatch(addTranslation(customTranslation));\n\n\n\n\n\n\nNested data format\n\n\nBoth types of translation data support nested data format to help with organization of translations, and avoiding naming collisions with translation keys.\n\n\n Multiple language format \n\n\n{\n  \nwelcome\n {\n    \nbanner\n: {\n      \ngreeting\n: [\nHello\n, \nBonjour\n, \nHola\n]\n    },\n    \nfooter\n: {\n      \nfarewell\n: [\nGoodbye\n, \nAu revoir\n, \nAdi\u00f3s\n]\n    }\n  }\n}\n\n\n\n\n Single language format \n\n\n// en.json\n{\n  \nwelcome\n {\n    \nbanner\n: {\n      \ngreeting\n: \nHello\n\n    },\n    \nfooter\n: {\n      \nfarewell\n: \nGoodbye\n\n    }\n  }\n}\n\n// fr.json\n{\n  \nwelcome\n {\n    \nbanner\n: {\n      \ngreeting\n: \nBonjour\n\n    },\n    \nfooter\n: {\n      \nfarewell\n: \nAu revoir\n\n    }\n  }\n}\n\n// es.json\n{\n  \nwelcome\n {\n    \nbanner\n: {\n      \ngreeting\n: \nHola\n\n    },\n    \nfooter\n: {\n      \nfarewell\n: \nAdi\u00f3s\n\n    }\n  }\n}", 
            "title": "Formatting Translation Data"
        }, 
        {
            "location": "/formatting-translation-data/#multiple-language-format", 
            "text": "Use  addTranslation  to add data in this format.   The data is an object where the property name is your translation key, and the value is an array of translations. The translation key is used to identify the translation, and the value is an array that enforces the following...   Includes a translation for each language your app supports.  The order of the translation strings in the array matters! The order  MUST  follow the order of the languages array passed to  setLanguages .   Assuming your application has dispatched  setLanguages('en', 'fr', 'es') :  {\n   greeting : [\n     Hello ,      (en)\n     Bonjour ,    (fr)\n     Hola ,       (es)\n  ],\n   farewell : [\n     Goodbye ,    (en)\n     Au revoir ,  (fr)\n     Adi\u00f3s        (es)\n  ]\n}", 
            "title": "Multiple language format"
        }, 
        {
            "location": "/formatting-translation-data/#single-language-format", 
            "text": "Use  addTranslationForLanguage  to add data in this format.   The data is an object where the property name is your translation key, and the value is the translation for the language. With the single language format you would dispatch  addTranslationForLanguage  for each language you support.  Assuming your application  setLanguages('en', 'fr', 'es') :  // en.json\n{\n   greeting :  Hello ,\n   farewell :  Goodbye \n}\n\n// fr.json\n{\n   greeting : Bonjour ,\n   farewell :  Au revoir \n}\n\n// es.json\n{\n   greeting :  Hola ,\n   farewell :  Adi\u00f3s \n}", 
            "title": "Single language format"
        }, 
        {
            "location": "/formatting-translation-data/#custom-data-format", 
            "text": "If you cannot use the supported data formats there is a way to instruct react-localize-redux on how to handle your custom data. To do this you must pass the  translationTransform  option when dispatching the  intialize  action, which takes a function in the following format:   const transformationFunction = (translationData: Object, languagesCodes: string[]) =  {\n  // Your transformation logic goes here...\n};  This function is responsible for taking your custom data, and transforming it into the format required by react-localize-redux. You are responsible for writing the transformation logic, but after that the function will be run automatically whenever dispatching  addTranslation .  \n   Note \n   The transformation function will not be run if you use the  addTranslationForLanguage  action.    Example   For example if you had data in the following format that you wanted to use...  const customTranslation = {\n  en: {\n    title: 'Title',\n    subtitle: 'Subtitle'\n  },\n  fr: {\n    title: 'FR - Title',\n    subtitle: 'FR - Subtitle'\n  }\n};  You would need to transform it into this format to work with react-localize-redux.  const translations = {\n  title: ['Title', 'FR - Title'],\n  subtitle: ['Subtitle', 'FR - Subtitle']\n};  This is where the transformation function comes in - we need to write a function that takes the custom translationData and returns the react-localize-redux format. Here is an example of what that function could look like for the example custom data:  const transformFunction = (translationData, languageCodes) =  {\n  return Object.keys(translationData).reduce((prev, cur, index) =  {\n    const languageData = data[cur];\n\n    for(let prop in languageData) {\n      const values = prev[prop] || [];\n      prev[prop] = languageCodes.map((code, languageIndex) =  {\n        return index === languageIndex\n          ? languageData[prop]\n          : values[languageIndex];\n      })\n    }\n\n    return prev;\n  }, {});\n};  Now when you dispatch the  intialize  action make sure you set the  translationTransform  option equal to the  transformFunction . Now anytime you dispatch the  addTranslation  action the  transformFunction  will run on the translation data you are adding.  const languages = ['en', 'fr'];\nstore.dispatch(initialize(languages, { translationTransform: transformFunction }));\n\nstore.dispatch(addTranslation(customTranslation));", 
            "title": "Custom data format"
        }, 
        {
            "location": "/formatting-translation-data/#nested-data-format", 
            "text": "Both types of translation data support nested data format to help with organization of translations, and avoiding naming collisions with translation keys.   Multiple language format   {\n   welcome  {\n     banner : {\n       greeting : [ Hello ,  Bonjour ,  Hola ]\n    },\n     footer : {\n       farewell : [ Goodbye ,  Au revoir ,  Adi\u00f3s ]\n    }\n  }\n}   Single language format   // en.json\n{\n   welcome  {\n     banner : {\n       greeting :  Hello \n    },\n     footer : {\n       farewell :  Goodbye \n    }\n  }\n}\n\n// fr.json\n{\n   welcome  {\n     banner : {\n       greeting :  Bonjour \n    },\n     footer : {\n       farewell :  Au revoir \n    }\n  }\n}\n\n// es.json\n{\n   welcome  {\n     banner : {\n       greeting :  Hola \n    },\n     footer : {\n       farewell :  Adi\u00f3s \n    }\n  }\n}", 
            "title": "Nested data format"
        }, 
        {
            "location": "/features/", 
            "text": "Keep default translations in your components\n\n\nIf you are directly using the \ntranslate\n function then your component might look something like this:\n\n\nimport { getTranslate } from 'react-localize-redux';\n\nconst Heading = ({ translate }) =\n (\n  \nh1\n{ translate('heading-01') }\n/h1\n\n);\n\nconst mapStateToProps = state =\n ({ translate: getTranslate(state.locale) });\n\nexport default connect(mapStateToProps)(Greeting);\n\n\n\n\nNow the above works well enough, but beyond the key name of \nheading-01\n you have no context for the translation copy that will be inserted. With the \n\nTranslate\n component you can include your default language's translation directly in the component, which can help with context, searching, and debugging.\n\n\nimport { Translate } from 'react-localize-redux';\n\nexport const Heading = ({ translate }) =\n (\n  \nh1\n\n    \nTranslate id=\nheading-01\nHere is my English heading\n/Translate\n\n  \n/h1\n\n);\n\n\n\n\n\n\nPass multiple translations to components\n\n\nTo retrieve multiple translations using \ntranslate\n pass an array of translation keys instead of a single key. This will return an object with translated strings mapped to translation keys.\n\n\nSince \ntranslate\n returns an object we can use the object spread operator to pass the translations as props for the \nArticle\n component.\n\n\nconst translationData = {\n  heading: [\nHeading\n, \nHeading French\n],\n  article: {\n    title: [\nTitle\n, \nTitle French\n],\n    author: [\nBy ${ name }\n, \nBy French ${ name }\n],\n    desc: [\nDescription\n, \nDescription French\n]\n  }\n};\n\nconst Page = ({ translate }) =\n (\n  \ndiv\n\n    \nh1\n{ translate('heading') }\n/h1\n\n    \nTranslate\n\n      {translate =\n \n        \nArticle { ...translate(['article.title', 'article.author', 'article.desc'], { name: 'Ted' }) } /\n\n      }\n    \n/Translate\n\n  \n/div\n\n);\n\nconst Article = props =\n (\n  \ndiv\n\n    \nh2\n{ props['article.title'] }\n/h2\n\n    \nh3\n{ props['article.author'] }\n/h3\n\n    \np\n{ props['article.desc'] }\n/p\n\n  \n/div\n\n);\n\n\n\n\n\n\nInsert dynamic content into translations\n\n\nInsert dynamic content into your translation strings by inserting placeholders with the following format \n${ placeholder }\n.\n\n\n{\n  \ngreeting\n: [\n    \nHello ${ name }\n,\n    \nBonjour ${ name }\n\n  ]\n}\n\n\n\n\n Using Translate component \n\n\nUse the \ndata\n attribute to pass the data you want to swap in for placeholders.\n\n\nh1\n\n  \nTranslate id=\ngreeting\n data=\nTesty McTest\n\n    {`Hello ${ name }`}\n  \n/Translate\n\n\n/h1\n\n\n\n\n\n Using translate function \n\n\nPass in the data you want to swap in for placeholders to the \ntranslate\n function.\n\n\nh1\n{ translate('greeting', { name: 'Testy McTest' }) }\n/h1\n\n\n\n\n\n\n\nInclude HTML in translations\n\n\nInclude HTML in your translation strings and it will be rendered in your component.\n\n\n{\n  \ngoogle-link\n: [\n    \na href='https://www.google.en/'\nGoogle\n/a\n,\n    \na href='https://www.google.fr/'\nGoogle\n/a\n\n  ]\n}\n\n\n\n\n\n\nHandle custom translation data\n\n\nDoes react-localize-redux's supported translation data formats not work for you? That's ok - there is a way for you to use your own custom trnaslation data format. See \nFormatting Transltion Data - Custom data format\n for full documentation.\n\n\n\n\nAvoid naming collisions with nested translation data\n\n\n Multiple language format \n\n\n{\n  \nwelcome\n: {\n    \ngreeting\n: [\n      \nHello ${ name }!\n,\n      \nBonjour ${ name }!\n\n    ]\n  },\n  \ninfo\n: {\n    \ngreeting\n: [\n      \nHello\n,\n      \nBonjour\n\n    ]\n  }\n}\n\n\n\n\n Single language format \n\n\n{\n  \nwelcome\n: {\n    \ngreeting\n: \nHello ${ name }!\n\n  },\n  \ninfo\n: {\n    \ngreeting\n: \nHello\n\n  }\n}\n\n\n\n\nh1\n{ translate('welcome.greeting', { name: 'Testy McTest' }) }\n/h1\n\n\nh1\n{ translate('info.greeting') }\n/h1\n\n\n\n\n\n\n\nCustom missing translation messages\n\n\nBy default when a translation isn't found the following message will be rendered in it's place: \n'Missing translation key ${ key } for language ${ code }'\n. Where \nkey\n will be the missing translation key, and \ncode\n will be the language code.\n\n\nYou can also override this message with a custom message by passing in your own \nmissingTranslationMsg\n option.\n\n\n Example \n\n\nimport { initialize } from 'react-localize-redux';\n\nconst languages = ['en', 'fr', 'es'];\n\n// just like the default message you can include the ${key} and ${code} placeholders\nconst missingTranslationMsg = 'Oh man you missed translation: ${key} for languge ${code}!';\n\nstore.dispatch(initialize(languages, { missingTranslationMsg }));\n\n// Assuming there is no translation for \nmissing-key\n doesn't exist it would render following:\n// \nh1\nOh man you missed translation: missing-key for languge en!\n/h1\n\nconst MyComponent = props =\n \nh1\nTranslate id=\nmissing-key\nNo translations here!\n/Translate\n/h1\n;\n\n// You also have the option to override the global missingTranslationMsg option\n// by passing a custom message directly to the translate function\n const missingTranslationMsg = 'Whoops! Missing translation!';\n const AnotherComponent = props =\n \n  \nh1\n\n    \nTranslate id=\nmissing-key\n options={{ missingTranslationMsg }}\nMissing!\n/Translate\n\n  \n/h1\n;\n\n\n\n\n\n\nMissing translations callback\n\n\nIf you need a way to detect missing translations you can set the \nmissingTranslationCallback\n option. When set this callback will be triggered anytime the \ntranslate\n function detects an \nundefined\n translation.\n\n\n/**\n * The callback function will be called with the following arguments:\n * key - The key that was passed to the translate function\n * languageCode - The language code for the currently active language.\n */\nconst onMissingTranslation = (key, languageCode) =\n {\n  // here you can do whatever you want e.g. call back end service that will\n  // send email to translation team\n};\n\nstore.dispatch(initialize(languages), { missingTranslationCallback: onMissingTranslation });\n\n\n\n\n\n\nLoad translation data on demand\n\n\nIf you have a larger app you may want to break your translation data up into multiple files, or maybe your translation data is being loaded from a service. You can call \naddTranslation\n for each new translation file/service, and the new translation data will be added to your Redux store.\n\n\nAlso If you are using a tool like \nwebpack\n for bundling, then you can use \nasync code-splitting\n to split translations across bundles, and async load them when you need them.", 
            "title": "Features"
        }, 
        {
            "location": "/features/#keep-default-translations-in-your-components", 
            "text": "If you are directly using the  translate  function then your component might look something like this:  import { getTranslate } from 'react-localize-redux';\n\nconst Heading = ({ translate }) =  (\n   h1 { translate('heading-01') } /h1 \n);\n\nconst mapStateToProps = state =  ({ translate: getTranslate(state.locale) });\n\nexport default connect(mapStateToProps)(Greeting);  Now the above works well enough, but beyond the key name of  heading-01  you have no context for the translation copy that will be inserted. With the  Translate  component you can include your default language's translation directly in the component, which can help with context, searching, and debugging.  import { Translate } from 'react-localize-redux';\n\nexport const Heading = ({ translate }) =  (\n   h1 \n     Translate id= heading-01 Here is my English heading /Translate \n   /h1 \n);", 
            "title": "Keep default translations in your components"
        }, 
        {
            "location": "/features/#pass-multiple-translations-to-components", 
            "text": "To retrieve multiple translations using  translate  pass an array of translation keys instead of a single key. This will return an object with translated strings mapped to translation keys.  Since  translate  returns an object we can use the object spread operator to pass the translations as props for the  Article  component.  const translationData = {\n  heading: [ Heading ,  Heading French ],\n  article: {\n    title: [ Title ,  Title French ],\n    author: [ By ${ name } ,  By French ${ name } ],\n    desc: [ Description ,  Description French ]\n  }\n};\n\nconst Page = ({ translate }) =  (\n   div \n     h1 { translate('heading') } /h1 \n     Translate \n      {translate =  \n         Article { ...translate(['article.title', 'article.author', 'article.desc'], { name: 'Ted' }) } / \n      }\n     /Translate \n   /div \n);\n\nconst Article = props =  (\n   div \n     h2 { props['article.title'] } /h2 \n     h3 { props['article.author'] } /h3 \n     p { props['article.desc'] } /p \n   /div \n);", 
            "title": "Pass multiple translations to components"
        }, 
        {
            "location": "/features/#insert-dynamic-content-into-translations", 
            "text": "Insert dynamic content into your translation strings by inserting placeholders with the following format  ${ placeholder } .  {\n   greeting : [\n     Hello ${ name } ,\n     Bonjour ${ name } \n  ]\n}   Using Translate component   Use the  data  attribute to pass the data you want to swap in for placeholders.  h1 \n   Translate id= greeting  data= Testy McTest \n    {`Hello ${ name }`}\n   /Translate  /h1    Using translate function   Pass in the data you want to swap in for placeholders to the  translate  function.  h1 { translate('greeting', { name: 'Testy McTest' }) } /h1", 
            "title": "Insert dynamic content into translations"
        }, 
        {
            "location": "/features/#include-html-in-translations", 
            "text": "Include HTML in your translation strings and it will be rendered in your component.  {\n   google-link : [\n     a href='https://www.google.en/' Google /a ,\n     a href='https://www.google.fr/' Google /a \n  ]\n}", 
            "title": "Include HTML in translations"
        }, 
        {
            "location": "/features/#handle-custom-translation-data", 
            "text": "Does react-localize-redux's supported translation data formats not work for you? That's ok - there is a way for you to use your own custom trnaslation data format. See  Formatting Transltion Data - Custom data format  for full documentation.", 
            "title": "Handle custom translation data"
        }, 
        {
            "location": "/features/#avoid-naming-collisions-with-nested-translation-data", 
            "text": "Multiple language format   {\n   welcome : {\n     greeting : [\n       Hello ${ name }! ,\n       Bonjour ${ name }! \n    ]\n  },\n   info : {\n     greeting : [\n       Hello ,\n       Bonjour \n    ]\n  }\n}   Single language format   {\n   welcome : {\n     greeting :  Hello ${ name }! \n  },\n   info : {\n     greeting :  Hello \n  }\n}  h1 { translate('welcome.greeting', { name: 'Testy McTest' }) } /h1  h1 { translate('info.greeting') } /h1", 
            "title": "Avoid naming collisions with nested translation data"
        }, 
        {
            "location": "/features/#custom-missing-translation-messages", 
            "text": "By default when a translation isn't found the following message will be rendered in it's place:  'Missing translation key ${ key } for language ${ code }' . Where  key  will be the missing translation key, and  code  will be the language code.  You can also override this message with a custom message by passing in your own  missingTranslationMsg  option.   Example   import { initialize } from 'react-localize-redux';\n\nconst languages = ['en', 'fr', 'es'];\n\n// just like the default message you can include the ${key} and ${code} placeholders\nconst missingTranslationMsg = 'Oh man you missed translation: ${key} for languge ${code}!';\n\nstore.dispatch(initialize(languages, { missingTranslationMsg }));\n\n// Assuming there is no translation for  missing-key  doesn't exist it would render following:\n//  h1 Oh man you missed translation: missing-key for languge en! /h1 \nconst MyComponent = props =   h1 Translate id= missing-key No translations here! /Translate /h1 ;\n\n// You also have the option to override the global missingTranslationMsg option\n// by passing a custom message directly to the translate function\n const missingTranslationMsg = 'Whoops! Missing translation!';\n const AnotherComponent = props =  \n   h1 \n     Translate id= missing-key  options={{ missingTranslationMsg }} Missing! /Translate \n   /h1 ;", 
            "title": "Custom missing translation messages"
        }, 
        {
            "location": "/features/#missing-translations-callback", 
            "text": "If you need a way to detect missing translations you can set the  missingTranslationCallback  option. When set this callback will be triggered anytime the  translate  function detects an  undefined  translation.  /**\n * The callback function will be called with the following arguments:\n * key - The key that was passed to the translate function\n * languageCode - The language code for the currently active language.\n */\nconst onMissingTranslation = (key, languageCode) =  {\n  // here you can do whatever you want e.g. call back end service that will\n  // send email to translation team\n};\n\nstore.dispatch(initialize(languages), { missingTranslationCallback: onMissingTranslation });", 
            "title": "Missing translations callback"
        }, 
        {
            "location": "/features/#load-translation-data-on-demand", 
            "text": "If you have a larger app you may want to break your translation data up into multiple files, or maybe your translation data is being loaded from a service. You can call  addTranslation  for each new translation file/service, and the new translation data will be added to your Redux store.  Also If you are using a tool like  webpack  for bundling, then you can use  async code-splitting  to split translations across bundles, and async load them when you need them.", 
            "title": "Load translation data on demand"
        }, 
        {
            "location": "/faq/", 
            "text": "Change localeReducer default key name\n\n\n// TODO.....\n\n\nWhat if my translation data isn't in the required format?\n\n\nIf you don't have control over the translation data for your application you can use the \ntranslationTransform\n option. \nThis allows you to write a function that takes in your custom translation data, and outputs the data in the required format.\nSee \nCustom data format\n for documentaion.\n\n\n\n\nHow do I persist active language?\n\n\nPersisting the user\u2019s selected language  after a refresh can be done a few ways, and how that is done is really up to you. \nThe following are two approaches you could use:\n\n\n1. Save active language to local storage\n\n\nWhen you start your app check localstorage for an existing saved language. If one exists use that as default language, if not default to first language.\n\n\nconst languages = ['en', 'fr', 'es'];\nconst defaultLanguage = storage.getItem('language') || languages[0];\nstore.dispatch(initialize(languages, { defaultLanguage }));\n\n\n\n\nWhenever you change the active language update the language stored in localstorage.\n\n\nstore.dispatch(setActiveLanguage('fr'));\nstorage.setItem('language', 'fr');\n\n\n\n\n2. Keep active language in the url\n\n\nAssuming you're using \nreact-router\n you can use \nurl-params\n to track active language. Your url might look something like this, but the key is that it has the \n:language\n param. Now when you start your app use the url's language param, and set default language based on that.\n\n\nconst languages = ['en', 'fr', 'es'];\nconst defaultLanguage = this.props.match.params.language;\nstore.dispatch(initialize(languages, { defaultLanguage }));\n\n\n\n\n\n\nHow do I retrieve a translation for a language other than active language?\n\n\nLet's say your app's active language is English, but you want\nto display a single translation in French. You can accomplish this by passing \nTranslate\n the \ndefaultLanguage\n option. \n\n\nimport { Translate } from 'react-localize-redux';\n\nconst Greeting = () =\n (\n  \ndiv\n\n    \n!-- This will be English translation since active language is 'en' --\n\n    \nh1\nTranslate id=\ngreeting\n /\n/h1\n\n    \n!-- Since we specify defaultLanguage: 'fr' translation will be in French --\n\n    \nh1\nTranslate id=\ngreeting\n options={{defaultLanguage: 'fr'}} /\n/h1\n\n  \n/div\n\n);\n\n\n\n\n\n\nHow do I handle currency, date, and other localization transformations?\n\n\nThis logic is purposely excluded from react-localize-redux to ensure that both package size and API remian small. If you do require this logic you have the choice of writing it yourself, or using a third party library that specializes in that area e.g.(\nMoment\n for dates).\n\n\nHere's an example of a basic currency translation using \nreselect\n:\n\n\nimport { initialize } from 'react-localize-redux';\n\nconst languages = ['en', 'fr'];\n\nconst translations = {\n  currency: [\n$ ${value}\n, \n${value} $\n]\n};\n\nstore.dispatch(initialize(languages));\nstore.dispatch(addTranslation(translations));\n\nconst Transactions = ({translateCurrency}) =\n (\n  \nul\n\n    \nli\n{translateCurrency(1000)}\n/li\n     // renders $ 1,000 (en), 1 000 $ (fr)\n    \nli\n{translateCurrency(100000)}\n/li\n   // renders $ 100,000 (en), 100 000 $ (fr)\n    \nli\n{translateCurrency(500)}\n/li\n      // renders $ 500 (en), 500 $ (fr)\n  \n/ul\n\n);\n\nconst getTranslateSelector = (state) =\n getTranslate(state.locale);\nconst getActiveLanguageSelector = (state) =\n getActiveLanguage(state.locale);\n\n/**\n * Returns a function that takes a number, and formats it using\n * the current language, the currency translate data, and native toLocaleString \n */\nconst getTranslateCurrency = createSelector(\n  getTranslateSelector, getActiveLanguageSelector,\n  (translate, language) =\n (value) =\n {\n    const localizedValue = value.toLocaleString(language.code);\n    return translate('currency', {value: localizedValue});\n  }\n);\n\nconst mapStateToProps = state =\n ({\n  translateCurrency: getTranslateCurrency(state)\n});\n\nconst LocalizedTransactions = connect(mapStateToProps)(Transactions);\n\n\n\n\n\n\nCan I use \nImmutableJS\n?\n\n\nIf your redux state is an ImmutableJS \nMap\n you will need to do the following:\n\n\n Using Translate \n\n\nThe Translate component uses React's \nLegacy Context\n to provide all instances of the Translate component with required config. In order for Translate to work with ImmutableJS you'll need to add \ngetLocaleState\n, which you will take a function that converts the state back to plain ol' JS for Translate. You will want to add \ngetLocaleState\n as high up in your component tree as possible.\n\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { Provider } from 'react-redux';\nimport { toJS } from 'immutable';\n\nclass App extends React.Component\nany, any\n {\n  getChildContext() {\n    // state will be the entire redux store state tree\n    // you will want to return the state key you used for localeReducer\n    return {  \n      getLocaleState: state =\n state.toJS()['locale'];\n    };\n  }\n\n  render() {\n    return (\n      \nProvider store={ store }\n\n        ...\n      \n/Provider\n\n    );\n  }\n}\n\nApp.childContextTypes = {\n  getLocaleState:  PropTypes.func\n};\n\n\n\n\n Using localize HOC \n\n\nIf you're using the \nlocalize\n HOC you'll need to use the \ngetStateSlice\n option. This option allows you to instruct \nlocalize\n on how to read the state even though it's an ImmutableJS Map.\n\n\nimport React from 'react';\nimport { toJS } from 'immutable';\nimport { localize } from 'Localize';\n\n/**\n * The getStateSlice function will passed the entire state as a param.\n * You are responsible for returning the locale state slice.\n */\nconst getStateSlice = (state) =\n state.toJS()['locale'];\nlocalize(Component, 'locale', getStateSlice);\n\n\n\n\n\n\nHow does react-localize-redux differ from \nreact-intl\n?\n\n\n\n\nreact-intl\n is larger in size/complexity, and for good reason as it handles many things related to localization. e.g. Pluralization, currency. Where as with \nreact-localize-redux\n you could still do pluralization, and currency, but you'd be writing the formatting functionality yourself. \n\n\n\n\n\nreact-intl\n doesn't work with Redux out of the box, and needs an additional library \nreact-intl-redux\n to add support.\n\n\n\n\n\nFor further discussion on this topic see \noriginal github issue\n.\n\n\n\n\n\n\nCan I use Translate component with React 15.x.x?\n\n\nIf you want to use the \nTranslate\n component it is recommended that you update to React 16, but if you don't have that luxury the \nfollowing work arounds may work for you:\n\n\n1.\n Only use Translate's render props API option.\n\n\n// use this...\n\nTranslate\n\n  {translate =\n\n    \nh1\n{ translate('heading') }\n/h1\n\n  }\n\n/Translate\n\n\n// not this...\n\nTranslate id=\nheading\nHello\n/Translate\n\n\n\n\n\n\n\n2.\n Wrap any text only translations in an HTML element\n\n\nReact 16 supports rendering \nfragements and strings\n, which allows for components to render plain text. Previous React versions you would need to manually wrap your text in an HTML element, which is what you will need to do for text passed to Translate.\n\n\n\n  \nImportant\n\n  \nI recommend not overusing this approach, as it results in unecessary HTML markup being added to your translation data.\n\n\n\n\n\nconst translations = {\n  heading: ['\nspan\nHello\n/span\n', '\nspan\nBonjour\n/span\n']\n};\n\n\nTranslate id=\nheading\n /", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#change-localereducer-default-key-name", 
            "text": "// TODO.....", 
            "title": "Change localeReducer default key name"
        }, 
        {
            "location": "/faq/#what-if-my-translation-data-isnt-in-the-required-format", 
            "text": "If you don't have control over the translation data for your application you can use the  translationTransform  option. \nThis allows you to write a function that takes in your custom translation data, and outputs the data in the required format.\nSee  Custom data format  for documentaion.", 
            "title": "What if my translation data isn't in the required format?"
        }, 
        {
            "location": "/faq/#how-do-i-persist-active-language", 
            "text": "Persisting the user\u2019s selected language  after a refresh can be done a few ways, and how that is done is really up to you. \nThe following are two approaches you could use:  1. Save active language to local storage  When you start your app check localstorage for an existing saved language. If one exists use that as default language, if not default to first language.  const languages = ['en', 'fr', 'es'];\nconst defaultLanguage = storage.getItem('language') || languages[0];\nstore.dispatch(initialize(languages, { defaultLanguage }));  Whenever you change the active language update the language stored in localstorage.  store.dispatch(setActiveLanguage('fr'));\nstorage.setItem('language', 'fr');  2. Keep active language in the url  Assuming you're using  react-router  you can use  url-params  to track active language. Your url might look something like this, but the key is that it has the  :language  param. Now when you start your app use the url's language param, and set default language based on that.  const languages = ['en', 'fr', 'es'];\nconst defaultLanguage = this.props.match.params.language;\nstore.dispatch(initialize(languages, { defaultLanguage }));", 
            "title": "How do I persist active language?"
        }, 
        {
            "location": "/faq/#how-do-i-retrieve-a-translation-for-a-language-other-than-active-language", 
            "text": "Let's say your app's active language is English, but you want\nto display a single translation in French. You can accomplish this by passing  Translate  the  defaultLanguage  option.   import { Translate } from 'react-localize-redux';\n\nconst Greeting = () =  (\n   div \n     !-- This will be English translation since active language is 'en' -- \n     h1 Translate id= greeting  / /h1 \n     !-- Since we specify defaultLanguage: 'fr' translation will be in French -- \n     h1 Translate id= greeting  options={{defaultLanguage: 'fr'}} / /h1 \n   /div \n);", 
            "title": "How do I retrieve a translation for a language other than active language?"
        }, 
        {
            "location": "/faq/#how-do-i-handle-currency-date-and-other-localization-transformations", 
            "text": "This logic is purposely excluded from react-localize-redux to ensure that both package size and API remian small. If you do require this logic you have the choice of writing it yourself, or using a third party library that specializes in that area e.g.( Moment  for dates).  Here's an example of a basic currency translation using  reselect :  import { initialize } from 'react-localize-redux';\n\nconst languages = ['en', 'fr'];\n\nconst translations = {\n  currency: [ $ ${value} ,  ${value} $ ]\n};\n\nstore.dispatch(initialize(languages));\nstore.dispatch(addTranslation(translations));\n\nconst Transactions = ({translateCurrency}) =  (\n   ul \n     li {translateCurrency(1000)} /li      // renders $ 1,000 (en), 1 000 $ (fr)\n     li {translateCurrency(100000)} /li    // renders $ 100,000 (en), 100 000 $ (fr)\n     li {translateCurrency(500)} /li       // renders $ 500 (en), 500 $ (fr)\n   /ul \n);\n\nconst getTranslateSelector = (state) =  getTranslate(state.locale);\nconst getActiveLanguageSelector = (state) =  getActiveLanguage(state.locale);\n\n/**\n * Returns a function that takes a number, and formats it using\n * the current language, the currency translate data, and native toLocaleString \n */\nconst getTranslateCurrency = createSelector(\n  getTranslateSelector, getActiveLanguageSelector,\n  (translate, language) =  (value) =  {\n    const localizedValue = value.toLocaleString(language.code);\n    return translate('currency', {value: localizedValue});\n  }\n);\n\nconst mapStateToProps = state =  ({\n  translateCurrency: getTranslateCurrency(state)\n});\n\nconst LocalizedTransactions = connect(mapStateToProps)(Transactions);", 
            "title": "How do I handle currency, date, and other localization transformations?"
        }, 
        {
            "location": "/faq/#can-i-use-immutablejs", 
            "text": "If your redux state is an ImmutableJS  Map  you will need to do the following:   Using Translate   The Translate component uses React's  Legacy Context  to provide all instances of the Translate component with required config. In order for Translate to work with ImmutableJS you'll need to add  getLocaleState , which you will take a function that converts the state back to plain ol' JS for Translate. You will want to add  getLocaleState  as high up in your component tree as possible.  import React from 'react';\nimport PropTypes from 'prop-types';\nimport { Provider } from 'react-redux';\nimport { toJS } from 'immutable';\n\nclass App extends React.Component any, any  {\n  getChildContext() {\n    // state will be the entire redux store state tree\n    // you will want to return the state key you used for localeReducer\n    return {  \n      getLocaleState: state =  state.toJS()['locale'];\n    };\n  }\n\n  render() {\n    return (\n       Provider store={ store } \n        ...\n       /Provider \n    );\n  }\n}\n\nApp.childContextTypes = {\n  getLocaleState:  PropTypes.func\n};   Using localize HOC   If you're using the  localize  HOC you'll need to use the  getStateSlice  option. This option allows you to instruct  localize  on how to read the state even though it's an ImmutableJS Map.  import React from 'react';\nimport { toJS } from 'immutable';\nimport { localize } from 'Localize';\n\n/**\n * The getStateSlice function will passed the entire state as a param.\n * You are responsible for returning the locale state slice.\n */\nconst getStateSlice = (state) =  state.toJS()['locale'];\nlocalize(Component, 'locale', getStateSlice);", 
            "title": "Can I use ImmutableJS?"
        }, 
        {
            "location": "/faq/#how-does-react-localize-redux-differ-from-react-intl", 
            "text": "react-intl  is larger in size/complexity, and for good reason as it handles many things related to localization. e.g. Pluralization, currency. Where as with  react-localize-redux  you could still do pluralization, and currency, but you'd be writing the formatting functionality yourself.    react-intl  doesn't work with Redux out of the box, and needs an additional library  react-intl-redux  to add support.   For further discussion on this topic see  original github issue .", 
            "title": "How does react-localize-redux differ from react-intl?"
        }, 
        {
            "location": "/faq/#can-i-use-translate-component-with-react-15xx", 
            "text": "If you want to use the  Translate  component it is recommended that you update to React 16, but if you don't have that luxury the \nfollowing work arounds may work for you:  1.  Only use Translate's render props API option.  // use this... Translate \n  {translate = \n     h1 { translate('heading') } /h1 \n  } /Translate \n\n// not this... Translate id= heading Hello /Translate    2.  Wrap any text only translations in an HTML element  React 16 supports rendering  fragements and strings , which allows for components to render plain text. Previous React versions you would need to manually wrap your text in an HTML element, which is what you will need to do for text passed to Translate.  \n   Important \n   I recommend not overusing this approach, as it results in unecessary HTML markup being added to your translation data.   const translations = {\n  heading: [' span Hello /span ', ' span Bonjour /span ']\n}; Translate id= heading  /", 
            "title": "Can I use Translate component with React 15.x.x?"
        }, 
        {
            "location": "/api/action-creators/", 
            "text": "initialize(languages, [options])\n\n\nDispatch this action when your app is initialized, and pass in which languages you are supporting in your translations. An optional \noptions\n param can be passed to configure additional settings.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlanguages\n\n\nstring [] or \n{ name: string, code: string } []\n\n\nAn array of language codes or named language objects.\n\n\n\n\n\n\n[options]\n\n\nobject\n\n\nAdditional configuration options\n\n\n\n\n\n\n\n\n Options: \n\n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndefaultLanguage\n\n\nstring\n\n\nlanguages[0]\n\n\nThe language code for the language you'd like to set as the defualt.\n\n\n\n\n\n\nrenderInnerHtml\n\n\nboolean\n\n\ntrue\n\n\nControls whether HTML in your translations will be rendered or returned as a plain string.\n\n\n\n\n\n\nshowMissingTranslationMsg\n\n\nboolean\n\n\ntrue\n\n\nControls whether missing translation message will be rendered when translation is undefined.\n\n\n\n\n\n\nmissingTranslationMsg\n\n\nstring\n\n\nMissing translation key ${key} for language ${code}\n\n\nA message that will be rendered in place of missing translations\n\n\n\n\n\n\nmissingTranslationCallback\n\n\nfunction\n\n\nundefined\n\n\nA function that will be called when attempting to get an undefined translation. See \nHandle missing translations\n for details.\n\n\n\n\n\n\ntranslationTransform\n\n\nfunction\n\n\nundefined\n\n\nA transformation function that will be applied to translation data. See \nCustom data format\n for details.\n\n\n\n\n\n\nignoreTranslateChildren\n\n\nboolean\n\n\nfalse\n\n\nA flag that determines whether or not to add the children of \nTranslate\n to the default language. This can be useful for defining default values in tests without adding them to translations.\n\n\n\n\n\n\n\n\n\n  \nDeprecated\n\n  \nshowMissingTranslationMsg\n - will be deprecated in the next major release, as you can set \nmissingTranslationMsg= ''\n  to accomplish the same thing as \nshowMissingTranslationMsg=false\n.\n\n\n\n\n\n\n  \nImportant\n\n  \nIf you're adding translation data from un-trusted sources make sure you set \nrenderInnerHtml\n option to \nfalse\n. In order to render HTML tags in translations react-localize-redux uses React's \ndangerouslySetInnerHTML\n, which has \nrisks\n when used improperly. For this reason in the next major release this option will be set to \nfalse\n by default to align with \ndangerouslySetInnerHTML\n.\n\n\n\n\n\n Usage: \n\n\n// with named languages \nconst languages = [\n  { name: 'English', code: 'en' },\n  { name: 'French', code: 'fr' },\n  { name: 'Spanish', code: 'es' }\n];\nstore.dispatch(initialize(languages));\n\n// with language codes only\nconst languages = ['en', 'fr', 'es'];\nstore.dispatch(initialize(languages));\n\n// if you wanted 'fr' to be default language instead of 'en'\nstore.dispatch(initialize(languages, { defaultLanguage: 'fr' }));\n\n\n\n\n\n\nsetLanguages(languages, [defaultActiveLanguage])\n\n\n\n  \nDeprecated\n\n  \nThis has been replaced by the \ninitialize\n action creator, and will be removed in the next major version.\n\n\n\n\n\nDispatch this action to set which languages you are supporting in your translations. If \ndefaultActiveLanguage\n is not passed then the first language in the \nlanguages\n array will be used.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlanguages\n\n\nstring []\n\n\nAn array of languages codes\n\n\n\n\n\n\n[defaultActiveLanguage]\n\n\nstring\n\n\nPass a language code to override the default active language.\n\n\n\n\n\n\n\n\n Usage: \n\n\nconst languages = ['en', 'fr', 'es'];\n\nstore.dispatch(setLanguages(languages));\n\n// if you wanted 'fr' to be default language instead of 'en'\nstore.dispatch(setLanguages(languages, 'fr'));\n\n\n\n\n\n\naddTranslation(data)\n\n\nDispatch this action to add translation data for multiple languages from a json file, or vanilla JS to your redux store. Please see \nformatting translation data\n to ensure your data is in the proper format. \n\n\n Arguments \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\njson | object\n\n\nTranslation data in the \nrequired format\n\n\n\n\n\n\n\n\n Usage: \n\n\n// assuming your app has set languages ['en', 'fr']\nconst welcomePageTranslations = {\n  greeting: ['Hi!', 'Bonjour!'],\n  farewell: ['Bye!', 'Au revoir!']\n};\n\nstore.dispatch(addTranslation(welcomePageTranslations));\n\n\n\n\n\n\naddTranslationForLanguage(data, language)\n\n\nDispatch this action to add translation data for a single language from a json file, or vanilla JS to your redux store. Please see \nformatting translation data\n to ensure your data is in the proper format. \n\n\n Arguments \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\njson | object\n\n\nTranslation data in the \nrequired format\n\n\n\n\n\n\nlanguage\n\n\nstring\n\n\nThe language code this translation data belongs to\n\n\n\n\n\n\n\n\n Usage: \n\n\n// assuming your app has set languages ['en', 'fr']\nconst welcomePageEnglish = {\n  greeting: 'Hi!',\n  farewell: 'Bye!'\n};\n\nstore.dispatch(addTranslationForLanguage(welcomePageEnglish, 'en'));\n\n\n\n\n\n\nsetActiveLanguage(language)\n\n\nRedux action creator\n to change the current language being used.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlanguage\n\n\nstring\n\n\nThe language code you want to set as active.\n\n\n\n\n\n\n\n\n Usage: \n\n\n// assuming your app has set languages ['en', 'fr']\nstore.dispatch(setActiveLanguage('fr'));", 
            "title": "Action Creators"
        }, 
        {
            "location": "/api/action-creators/#initializelanguages-options", 
            "text": "Dispatch this action when your app is initialized, and pass in which languages you are supporting in your translations. An optional  options  param can be passed to configure additional settings.   Arguments:      name  Type  Description      languages  string [] or  { name: string, code: string } []  An array of language codes or named language objects.    [options]  object  Additional configuration options      Options:      name  Type  Default  Description      defaultLanguage  string  languages[0]  The language code for the language you'd like to set as the defualt.    renderInnerHtml  boolean  true  Controls whether HTML in your translations will be rendered or returned as a plain string.    showMissingTranslationMsg  boolean  true  Controls whether missing translation message will be rendered when translation is undefined.    missingTranslationMsg  string  Missing translation key ${key} for language ${code}  A message that will be rendered in place of missing translations    missingTranslationCallback  function  undefined  A function that will be called when attempting to get an undefined translation. See  Handle missing translations  for details.    translationTransform  function  undefined  A transformation function that will be applied to translation data. See  Custom data format  for details.    ignoreTranslateChildren  boolean  false  A flag that determines whether or not to add the children of  Translate  to the default language. This can be useful for defining default values in tests without adding them to translations.     \n   Deprecated \n   showMissingTranslationMsg  - will be deprecated in the next major release, as you can set  missingTranslationMsg= ''   to accomplish the same thing as  showMissingTranslationMsg=false .   \n   Important \n   If you're adding translation data from un-trusted sources make sure you set  renderInnerHtml  option to  false . In order to render HTML tags in translations react-localize-redux uses React's  dangerouslySetInnerHTML , which has  risks  when used improperly. For this reason in the next major release this option will be set to  false  by default to align with  dangerouslySetInnerHTML .    Usage:   // with named languages \nconst languages = [\n  { name: 'English', code: 'en' },\n  { name: 'French', code: 'fr' },\n  { name: 'Spanish', code: 'es' }\n];\nstore.dispatch(initialize(languages));\n\n// with language codes only\nconst languages = ['en', 'fr', 'es'];\nstore.dispatch(initialize(languages));\n\n// if you wanted 'fr' to be default language instead of 'en'\nstore.dispatch(initialize(languages, { defaultLanguage: 'fr' }));", 
            "title": "initialize(languages, [options])"
        }, 
        {
            "location": "/api/action-creators/#setlanguageslanguages-defaultactivelanguage", 
            "text": "Deprecated \n   This has been replaced by the  initialize  action creator, and will be removed in the next major version.   Dispatch this action to set which languages you are supporting in your translations. If  defaultActiveLanguage  is not passed then the first language in the  languages  array will be used.   Arguments:      name  Type  Description      languages  string []  An array of languages codes    [defaultActiveLanguage]  string  Pass a language code to override the default active language.      Usage:   const languages = ['en', 'fr', 'es'];\n\nstore.dispatch(setLanguages(languages));\n\n// if you wanted 'fr' to be default language instead of 'en'\nstore.dispatch(setLanguages(languages, 'fr'));", 
            "title": "setLanguages(languages, [defaultActiveLanguage])"
        }, 
        {
            "location": "/api/action-creators/#addtranslationdata", 
            "text": "Dispatch this action to add translation data for multiple languages from a json file, or vanilla JS to your redux store. Please see  formatting translation data  to ensure your data is in the proper format.    Arguments      name  Type  Description      data  json | object  Translation data in the  required format      Usage:   // assuming your app has set languages ['en', 'fr']\nconst welcomePageTranslations = {\n  greeting: ['Hi!', 'Bonjour!'],\n  farewell: ['Bye!', 'Au revoir!']\n};\n\nstore.dispatch(addTranslation(welcomePageTranslations));", 
            "title": "addTranslation(data)"
        }, 
        {
            "location": "/api/action-creators/#addtranslationforlanguagedata-language", 
            "text": "Dispatch this action to add translation data for a single language from a json file, or vanilla JS to your redux store. Please see  formatting translation data  to ensure your data is in the proper format.    Arguments      name  Type  Description      data  json | object  Translation data in the  required format    language  string  The language code this translation data belongs to      Usage:   // assuming your app has set languages ['en', 'fr']\nconst welcomePageEnglish = {\n  greeting: 'Hi!',\n  farewell: 'Bye!'\n};\n\nstore.dispatch(addTranslationForLanguage(welcomePageEnglish, 'en'));", 
            "title": "addTranslationForLanguage(data, language)"
        }, 
        {
            "location": "/api/action-creators/#setactivelanguagelanguage", 
            "text": "Redux action creator  to change the current language being used.   Arguments:      name  Type  Description      language  string  The language code you want to set as active.      Usage:   // assuming your app has set languages ['en', 'fr']\nstore.dispatch(setActiveLanguage('fr'));", 
            "title": "setActiveLanguage(language)"
        }, 
        {
            "location": "/api/selectors/", 
            "text": "getTranslate(state)\n\n\nA selector that takes the localeReducer slice of your \nstate\n and returns the \ntranslate\n function. This function will have access to any and all translations that were added to your redux store.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstate\n\n\nany\n\n\nThe localeReducer slice of your state.\n\n\n\n\n\n\n\n\n Returns: \n\n\nReturns the \ntranslate\n function.\n\n\n Usage: \n\n\nconst Greeting = ({ translate }) =\n \nh1\n{ translate('greeting') }\n/h1\n\n\nconst mapStateToProps = state =\n ({ translate: getTranslate(state.locale) });\nexport default connect(mapStateToProps)(Greeting);\n\n\n\n\n\n\ntranslate(key: string | string[], [data], [options])\n\n\nThe \ngetTranslate\n selector will return the \ntranslate\n function, which is used to add localized strings to your connected React components. The translate function will return single, or multiple translations depending on the arguments passed. \n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nstring | string []\n\n\nPass a single key or multiple keys from your translation data.\n\n\n\n\n\n\n[data]\n\n\nobject\n\n\nOptional data to be used in your localized strings for \nvariable replacement\n.\n\n\n\n\n\n\n[options]\n\n\nobject\n\n\nOverride \nrenderInnerHtml\n, \ndefaultLanguage\n, \nmissingTranslationMsg\n, and \nmissingTranslationCallback\n \ninitialize optons\n for translation.\n\n\n\n\n\n\n\n\n Returns: \n\n\nIf a single key is passed then a single localized value will be returned in one of the following formats:\n\n\n\n\nif localized string contains HTML\n a \nReactElement\n will be returned.\n\n\nif localized string contains NO HTML\n a \nstring\n will be returned.\n\n\n\n\nIf multiple keys are passed then multiple localized values will be returned in the following format:\n\n\n{\n  'article.title': 'Article Title',\n  'article.author': 'Ted Tedson',\n  'article.desc': 'My awesome article description',\n  'article.code': '\ncode\nconsole.log(\nhi\n)\n/code\n'\n}\n\n\n\n\n Usage: \n\n\nconst Article = props =\n (\n  \ndiv\n\n    \nh2\n{ props['article.title'] }\n/h2\n\n    \nh3\n{ props['article.author'] }\n/h3\n\n    \np\n{ props['article.desc'] }\n/p\n\n  \n/div\n\n);\n\nconst Page = ({ translate }) =\n (\n  \ndiv\n\n    \nh1\n{ translate('heading') }\n/h1\n\n    \n!-- Instead of pulling translation based on activeLanguage, specify language using defaultLanguage option --\n\n    \np\n{ translate('heading', null, { defaultLanguage: 'fr' }) }\n/p\n\n    \n!-- override renderHtml option for this translation --\n\n    \np\n{ translate('article.code', null, { renderInnerHtml: false }) }\n/p\n\n    \n!-- pass multiple translations --\n\n    \nArticle { ...translate(['article.title', 'article.author', 'article.desc'], { name: 'Ted' }) } /\n\n  \n/div\n\n);\n\nconst mapStateToProps = state =\n ({ translate: getTranslate(state.locale) });\nexport default connect(mapStateToProps)(Page);\n\n\n\n\n\n\ngetActiveLanguage(state)\n\n\nA selector that takes the localeReducer slice of your \nstate\n and returns the currently active language object.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstate\n\n\nany\n\n\nThe localeReducer slice of your state.\n\n\n\n\n\n\n\n\n Returns: \n\n\nThe active language object \n\n\n{ name: 'English', code: 'en', active: true }\n\n\n\n\n Usage: \n\n\nconst Greeting = ({ currentLanguage }) =\n \nh1\nMy language is: { currentLanguage }\n/h1\n\n\nconst mapStateToProps = state =\n ({ currentLanguage: getActiveLanguage(state.locale).code });\nexport default connect(mapStateToProps)(Greeting);\n\n\n\n\n\n\ngetLanguages(state)\n\n\nA selector that takes the localeReducer slice of your \nstate\n and returns the languages you set.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstate\n\n\nany\n\n\nThe localeReducer slice of your state.\n\n\n\n\n\n\n\n\n Returns: \n \n\n\nAn array of language codes \n\n\n[{ name: 'English', code: 'en', active: true }, { name: 'French', code: 'fr', active: false }]\n\n\n\n\n Usage: \n\n\nconst LanguageSelector = ({ languages }) =\n (\n  \nul\n\n    { languages.map(language =\n (\n      \na onClick={ () =\n { setActiveLanguage(language.code) }\n{ language.name }\n/a\n\n    )}\n  \n/ul\n\n);\n\nconst mapStateToProps = state =\n ({ languages: getLanguages(state.locale) });\nexport default connect(mapStateToProps, { setActiveLanguage })(Greeting);\n\n\n\n\n\n\ngetTranslations(state)\n\n\nA selector that takes your redux \nstate\n and returns all the translation data in your redux store.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstate\n\n\nany\n\n\nThe localeReducer slice of your state.\n\n\n\n\n\n\n\n\n Returns: \n \n\n\nAn object containing all your translation data.", 
            "title": "Selectors"
        }, 
        {
            "location": "/api/selectors/#gettranslatestate", 
            "text": "A selector that takes the localeReducer slice of your  state  and returns the  translate  function. This function will have access to any and all translations that were added to your redux store.   Arguments:      name  Type  Description      state  any  The localeReducer slice of your state.      Returns:   Returns the  translate  function.   Usage:   const Greeting = ({ translate }) =   h1 { translate('greeting') } /h1 \n\nconst mapStateToProps = state =  ({ translate: getTranslate(state.locale) });\nexport default connect(mapStateToProps)(Greeting);", 
            "title": "getTranslate(state)"
        }, 
        {
            "location": "/api/selectors/#translatekey-string-string-data-options", 
            "text": "The  getTranslate  selector will return the  translate  function, which is used to add localized strings to your connected React components. The translate function will return single, or multiple translations depending on the arguments passed.    Arguments:      name  Type  Description      key  string | string []  Pass a single key or multiple keys from your translation data.    [data]  object  Optional data to be used in your localized strings for  variable replacement .    [options]  object  Override  renderInnerHtml ,  defaultLanguage ,  missingTranslationMsg , and  missingTranslationCallback   initialize optons  for translation.      Returns:   If a single key is passed then a single localized value will be returned in one of the following formats:   if localized string contains HTML  a  ReactElement  will be returned.  if localized string contains NO HTML  a  string  will be returned.   If multiple keys are passed then multiple localized values will be returned in the following format:  {\n  'article.title': 'Article Title',\n  'article.author': 'Ted Tedson',\n  'article.desc': 'My awesome article description',\n  'article.code': ' code console.log( hi ) /code '\n}   Usage:   const Article = props =  (\n   div \n     h2 { props['article.title'] } /h2 \n     h3 { props['article.author'] } /h3 \n     p { props['article.desc'] } /p \n   /div \n);\n\nconst Page = ({ translate }) =  (\n   div \n     h1 { translate('heading') } /h1 \n     !-- Instead of pulling translation based on activeLanguage, specify language using defaultLanguage option -- \n     p { translate('heading', null, { defaultLanguage: 'fr' }) } /p \n     !-- override renderHtml option for this translation -- \n     p { translate('article.code', null, { renderInnerHtml: false }) } /p \n     !-- pass multiple translations -- \n     Article { ...translate(['article.title', 'article.author', 'article.desc'], { name: 'Ted' }) } / \n   /div \n);\n\nconst mapStateToProps = state =  ({ translate: getTranslate(state.locale) });\nexport default connect(mapStateToProps)(Page);", 
            "title": "translate(key: string | string[], [data], [options])"
        }, 
        {
            "location": "/api/selectors/#getactivelanguagestate", 
            "text": "A selector that takes the localeReducer slice of your  state  and returns the currently active language object.   Arguments:      name  Type  Description      state  any  The localeReducer slice of your state.      Returns:   The active language object   { name: 'English', code: 'en', active: true }   Usage:   const Greeting = ({ currentLanguage }) =   h1 My language is: { currentLanguage } /h1 \n\nconst mapStateToProps = state =  ({ currentLanguage: getActiveLanguage(state.locale).code });\nexport default connect(mapStateToProps)(Greeting);", 
            "title": "getActiveLanguage(state)"
        }, 
        {
            "location": "/api/selectors/#getlanguagesstate", 
            "text": "A selector that takes the localeReducer slice of your  state  and returns the languages you set.   Arguments:      name  Type  Description      state  any  The localeReducer slice of your state.      Returns:     An array of language codes   [{ name: 'English', code: 'en', active: true }, { name: 'French', code: 'fr', active: false }]   Usage:   const LanguageSelector = ({ languages }) =  (\n   ul \n    { languages.map(language =  (\n       a onClick={ () =  { setActiveLanguage(language.code) } { language.name } /a \n    )}\n   /ul \n);\n\nconst mapStateToProps = state =  ({ languages: getLanguages(state.locale) });\nexport default connect(mapStateToProps, { setActiveLanguage })(Greeting);", 
            "title": "getLanguages(state)"
        }, 
        {
            "location": "/api/selectors/#gettranslationsstate", 
            "text": "A selector that takes your redux  state  and returns all the translation data in your redux store.   Arguments:      name  Type  Description      state  any  The localeReducer slice of your state.      Returns:     An object containing all your translation data.", 
            "title": "getTranslations(state)"
        }, 
        {
            "location": "/api/translate/", 
            "text": "Translate\n\n\nThe \nTranslate /\n component is the recommended way to access translations in your components.\n\n\n props: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nid\n\n\nstring\n\n\nPass the key of the translation data you want to insert.\n\n\n\n\n\n\ndata\n\n\nobject\n\n\nOptional data to be used in your localized strings for \nvariable replacement\n.\n\n\n\n\n\n\noptions\n\n\nobject\n\n\nOverride \nrenderInnerHtml\n, \ndefaultLanguage\n, \nmissingTranslationMsg\n, and \nmissingTranslationCallback\n \ninitialize optons\n for translation.\n\n\n\n\n\n\n\n\n Usage: \n\n\nIf you want to include your default language's translations in your component you can pass the translations as \nchildren\n to the \nTranslate /\n component. These translations will automatically be added to your redux store's translation data.\n\n\nimport { addTranslation } from 'react-localize-redux';\n\nconst translations = {\n  greeting: [\n    null, // default language translation will pull from Translate's children\n    'Bonjour'\n  ],\n  farewell: [\n    'goodbye',\n    'Au revoir'\n  ],\n  food: [\n    null,\n    '\nul\nli\nLait\n/li\nli\nbiscuits\n/li\n/ul\n'\n  ],\n  date: [\n    null,\n    'La date d\\'aujourd\\'hui est ${date}'\n  ]\n};\n\nstore.dispatch(addTranslation(translations));\n\n\n\n\nHere we access the translations we added above:\n\n\nimport { Translate } from 'react-localize-redux';\n\nconst Welcome = props =\n (\n  \ndiv\n\n    \n!-- \n      'Hello' would be inserted into translation data under the \n      default language for 'greeting' key.\n    --\n\n    \nTranslate id=\ngreeting\nHello\n/Translate\n\n\n    \n!-- \n      Overide 'goodbye' with 'Bye Bye!' in translation data under the\n      default language for 'farewell' key.\n    --\n\n    \nTranslate id=\nfarewell\nBye Bye!\n/Translate\n\n\n    \n!-- \n      If you don't include the default translation in Translate's children\n      you will need to ensure you have set a value in your translation data.\n      In this case default translation would use 'goodbye' from translation data.\n    --\n\n    \nTranslate id=\nfarewell\n /\n\n\n    \n!-- \n      You can include HTML markup as children, but ensure you include \n      the same markup in your translation data.\n    --\n\n    \nTranslate id=\nfood\n\n      \nul\n\n        \nli\nMilk\n/li\n\n        \nli\nCookies\n/li\n\n      \n/ul\n\n    \n/Translate\n\n\n    \n!-- \n      You can insert translations with placeholder's for dynamic data.\n      Then pass data in using data prop.\n    --\n\n    \nTranslate id=\ndate\n data={{date: new Date()}}\n\n      {'Today\\'s date is ${date}'}\n    \n/Translate\n\n\n    \n!-- \n      You can override initialize options using the options prop.\n      Overriding renderInnerHtml to false to avoid rendering HTML markup.\n    --\n\n    \nTranslate id=\nfood\n options={{renderInnerHtml: false}}\n\n      \nul\n\n        \nli\nMilk\n/li\n\n        \nli\nCookies\n/li\n\n      \n/ul\n\n    \n/Translate\n\n  \n/div\n\n);\n\n\n\n\nYou can also pass Translate a function as it's child that returns the elements you want to render. This function is commonly referred to as a \nrender prop function\n, and is called with the following arguments:\n\n\n\n\n\n\n\n\nname\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntranslate\n\n\nSame as value returned from \ngetTranslate\n selector.\n\n\n\n\n\n\nactiveLanguage\n\n\nSame as value returned from \ngetActiveLanguage\n selector.\n\n\n\n\n\n\nlanguages\n\n\nSame as value returned from \ngetLanguages\n selector.\n\n\n\n\n\n\n\n\nimport { Translate } from 'react-localize-redux';\n\nconst Welcome = props =\n (\n  \nTranslate\n\n    {(translate, activeLanguage, languages) =\n \n      \ndiv\n\n        \nh1\nThe active language is: {activeLanguage.name}\n/h2\n\n\n        \nh2\nLanguages:\n/h2\n\n        \nul\n\n          {languages.map(language =\n\n            \nli\n{language.name} - {language.code}\n/li\n\n          )}\n        \n/ul\n\n\n        \np\n{ translate('greeting') }\n/p\n\n        \np\n{ translate('farewell') }\n/p\n\n        \np\n{ translate('date', {date: new Date()}) }\n/p\n\n        \np\n{ translate('food', null, {renderInnerHtml: false}) }\n/p\n\n      \n/div\n\n    }\n  \n/Translate\n\n);", 
            "title": "Translate"
        }, 
        {
            "location": "/api/translate/#translate", 
            "text": "The  Translate /  component is the recommended way to access translations in your components.   props:      name  Type  Description      id  string  Pass the key of the translation data you want to insert.    data  object  Optional data to be used in your localized strings for  variable replacement .    options  object  Override  renderInnerHtml ,  defaultLanguage ,  missingTranslationMsg , and  missingTranslationCallback   initialize optons  for translation.      Usage:   If you want to include your default language's translations in your component you can pass the translations as  children  to the  Translate /  component. These translations will automatically be added to your redux store's translation data.  import { addTranslation } from 'react-localize-redux';\n\nconst translations = {\n  greeting: [\n    null, // default language translation will pull from Translate's children\n    'Bonjour'\n  ],\n  farewell: [\n    'goodbye',\n    'Au revoir'\n  ],\n  food: [\n    null,\n    ' ul li Lait /li li biscuits /li /ul '\n  ],\n  date: [\n    null,\n    'La date d\\'aujourd\\'hui est ${date}'\n  ]\n};\n\nstore.dispatch(addTranslation(translations));  Here we access the translations we added above:  import { Translate } from 'react-localize-redux';\n\nconst Welcome = props =  (\n   div \n     !-- \n      'Hello' would be inserted into translation data under the \n      default language for 'greeting' key.\n    -- \n     Translate id= greeting Hello /Translate \n\n     !-- \n      Overide 'goodbye' with 'Bye Bye!' in translation data under the\n      default language for 'farewell' key.\n    -- \n     Translate id= farewell Bye Bye! /Translate \n\n     !-- \n      If you don't include the default translation in Translate's children\n      you will need to ensure you have set a value in your translation data.\n      In this case default translation would use 'goodbye' from translation data.\n    -- \n     Translate id= farewell  / \n\n     !-- \n      You can include HTML markup as children, but ensure you include \n      the same markup in your translation data.\n    -- \n     Translate id= food \n       ul \n         li Milk /li \n         li Cookies /li \n       /ul \n     /Translate \n\n     !-- \n      You can insert translations with placeholder's for dynamic data.\n      Then pass data in using data prop.\n    -- \n     Translate id= date  data={{date: new Date()}} \n      {'Today\\'s date is ${date}'}\n     /Translate \n\n     !-- \n      You can override initialize options using the options prop.\n      Overriding renderInnerHtml to false to avoid rendering HTML markup.\n    -- \n     Translate id= food  options={{renderInnerHtml: false}} \n       ul \n         li Milk /li \n         li Cookies /li \n       /ul \n     /Translate \n   /div \n);  You can also pass Translate a function as it's child that returns the elements you want to render. This function is commonly referred to as a  render prop function , and is called with the following arguments:     name  Description      translate  Same as value returned from  getTranslate  selector.    activeLanguage  Same as value returned from  getActiveLanguage  selector.    languages  Same as value returned from  getLanguages  selector.     import { Translate } from 'react-localize-redux';\n\nconst Welcome = props =  (\n   Translate \n    {(translate, activeLanguage, languages) =  \n       div \n         h1 The active language is: {activeLanguage.name} /h2 \n\n         h2 Languages: /h2 \n         ul \n          {languages.map(language = \n             li {language.name} - {language.code} /li \n          )}\n         /ul \n\n         p { translate('greeting') } /p \n         p { translate('farewell') } /p \n         p { translate('date', {date: new Date()}) } /p \n         p { translate('food', null, {renderInnerHtml: false}) } /p \n       /div \n    }\n   /Translate \n);", 
            "title": "Translate"
        }, 
        {
            "location": "/api/localize/", 
            "text": "localize(Component, [reducerName], [getStateSlice])\n\n\n\n  \nDeprecated\n\n  \nThis feature will be removed in the next major version. See \nAdd translations to components\n for recommended options.\n\n\n\n\n\n\n  \nImportant\n\n  \nif your component is already using \nconnect\n then you should use the \ngetTranslate\n, and \ngetActiveLanguage\n selectors instead of \nlocalize\n.\n\n\n\n\n\nIf you have a component that just needs access to translations, and nothing else then you can use the \nlocalize\n higher-order function. When you pass your Component to localize it will automatically add \ntranslate\n and \ncurrentLanguage\n to props. \n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nComponent\n\n\nReactComponent\n\n\nThe localeReducer slice of your state.\n\n\n\n\n\n\n[reducerName]\n\n\nstring\n\n\nIf you added localeReducer with \ncombineReducers\n then you will need to pass the reducerName to localize.\n\n\n\n\n\n\n[getStateSlice]\n\n\nfunction\n\n\nAn optional param that allows for adding custom logic for retrieving the state slice. See \nCan I use ImmutableJS?\n for usage example.\n\n\n\n\n\n\n\n\n Returns: \n \n\n\nA higher-order React component that adds \ntranslate\n and \ncurrentLanguage\n to props.\n\n\n Usage: \n\n\nconst Greeting = ({ translate, currentLanguage }) =\n (\n  \nspan\n\n    \nh1\nlanguageCode: { currentLanguage }\n/h1\n\n    \nh2\n{ translate('greeting', { name: 'Testy McTest' }) }\n/h2\n\n  \n/span\n\n);\nexport default localize(Greeting, 'locale');", 
            "title": "localize - deprecated!"
        }, 
        {
            "location": "/api/localize/#localizecomponent-reducername-getstateslice", 
            "text": "Deprecated \n   This feature will be removed in the next major version. See  Add translations to components  for recommended options.   \n   Important \n   if your component is already using  connect  then you should use the  getTranslate , and  getActiveLanguage  selectors instead of  localize .   If you have a component that just needs access to translations, and nothing else then you can use the  localize  higher-order function. When you pass your Component to localize it will automatically add  translate  and  currentLanguage  to props.    Arguments:      name  Type  Description      Component  ReactComponent  The localeReducer slice of your state.    [reducerName]  string  If you added localeReducer with  combineReducers  then you will need to pass the reducerName to localize.    [getStateSlice]  function  An optional param that allows for adding custom logic for retrieving the state slice. See  Can I use ImmutableJS?  for usage example.      Returns:     A higher-order React component that adds  translate  and  currentLanguage  to props.   Usage:   const Greeting = ({ translate, currentLanguage }) =  (\n   span \n     h1 languageCode: { currentLanguage } /h1 \n     h2 { translate('greeting', { name: 'Testy McTest' }) } /h2 \n   /span \n);\nexport default localize(Greeting, 'locale');", 
            "title": "localize(Component, [reducerName], [getStateSlice])"
        }
    ]
}