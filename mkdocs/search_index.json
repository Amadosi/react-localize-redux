{
    "docs": [
        {
            "location": "/getting-started/", 
            "text": "1. Add reducer\n\n\n\n  \nNote\n\n  \nAlthough this example uses \nlocale\n for the reducer name, you can change this to a name of your choosing. Just ensure that you use your name when passing the state to selectors.\n\n\n\n\n\nimport { createStore, combineReducers } from 'redux';\nimport { user } from './reducers';\nimport { localeReducer as locale } from 'react-localize-redux';\n\nconst store = createStore(combineReducers({ user, locale }));\n\nconst App = props =\n {\n  return (\n    \nProvider store={ store }\n\n      ...\n    \n/Provider\n\n  );\n};\n\n\n\n\n\n\n2. Initialize languages\n\n\nDispatch \ninitialize\n action creator and pass in the languages for your app. By default the first language in the array will be set as the active language.\n\n\nimport { initialize } from 'react-localize-redux';\n\nconst languages = ['en', 'fr', 'es'];\nstore.dispatch(initialize(languages));\n\n\n\n\nTo set a different default active language set the \ndefaultLanguage\n option.\n\n\nconst languages = ['en', 'fr', 'es'];\nstore.dispatch(initialize(languages, { defaultLanguage: 'fr' }));\n\n\n\n\n\n\n3. Add translation data\n\n\nTypically you will store your translation data in json files, but the data can also be a vanilla JS object. \n\n\nIn order to add translation data to your application there are two action creators available - \naddTranslation\n and \naddTranslationForLanguage\n. Which one you use will depend on which format your translation data is in - see \nformatting transaltion data\n for more information.\n\n\n\n  \nNote\n\n  \nThe following assumes you are using \nwebpack\n to bundle json\n\n\n\n\n\n Multiple language format \n\n\nimport { addTranslation } from 'react-localize-redux';\n\nconst json = require('global.locale.json');\nstore.dispatch(addTranslation(json));\n\n\n\n\n Single language format \n\n\nimport { addTranslationForLanguage } from 'react-localize-redux';\n\nconst json = require('en.json');\nstore.dispatch(addTranslationForLanguage(json, 'en'));\n\n\n\n\n\n\n4. Change language\n\n\nDispatch \nsetActiveLanguage\n and pass the language.\n\n\nimport { setActiveLanguage } from 'react-localize-redux';\n\nstore.dispatch(setActiveLanguage('fr'));\n\n\n\n\n\n\n5. Translate components\n\n\nIf you have a component that is already using \nconnect\n use \ngetTranslate\n in your \nmapStateToProps\n to add the \ntranslate\n function to your component's props.\n\n\nimport { getTranslate } from 'react-localize-redux';\n\nconst Greeting = ({ translate, currentLanguage }) =\n (\n  \ndiv\n\n    \nh1\n{ translate('greeting') }\n/h1\n\n    \nbutton\n{ translate('farwell') }\n/button\n\n  \n/div\n\n);\n\nconst mapStateToProps = state =\n ({\n  translate: getTranslate(state.locale),\n  currentLanguage: getActiveLanguage(state.locale).code\n});\n\nexport default connect(mapStateToProps)(Greeting);\n\n\n\n\nFor components where you only need access to \ntranslate\n and \ncurrentLanguage\n you can use \nlocalize\n. This will automatically connect your component with the \ntranslate\n function and \ncurrentLanguage\n prop. \n\n\n\n  \nWarning\n\n  \nComponents that use \nlocalize\n still use \nconnect\n behind the scenes, which means you will want to avoid overusing \nlocalize\n. Instead \npass multiple translations to components\n when possible.\n\n\n\n\n\nimport { localize } from 'react-localize-redux';\n\nconst Greeting = ({ translate, currentLanguage }) =\n (\n  \ndiv\n\n    \nh1\n{ translate('greeting') }\n/h1\n\n    \nbutton\n{ translate('farwell') }\n/button\n\n  \n/div\n\n);\n\nexport default localize(Greeting, 'locale');", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#1-add-reducer", 
            "text": "Note \n   Although this example uses  locale  for the reducer name, you can change this to a name of your choosing. Just ensure that you use your name when passing the state to selectors.   import { createStore, combineReducers } from 'redux';\nimport { user } from './reducers';\nimport { localeReducer as locale } from 'react-localize-redux';\n\nconst store = createStore(combineReducers({ user, locale }));\n\nconst App = props =  {\n  return (\n     Provider store={ store } \n      ...\n     /Provider \n  );\n};", 
            "title": "1. Add reducer"
        }, 
        {
            "location": "/getting-started/#2-initialize-languages", 
            "text": "Dispatch  initialize  action creator and pass in the languages for your app. By default the first language in the array will be set as the active language.  import { initialize } from 'react-localize-redux';\n\nconst languages = ['en', 'fr', 'es'];\nstore.dispatch(initialize(languages));  To set a different default active language set the  defaultLanguage  option.  const languages = ['en', 'fr', 'es'];\nstore.dispatch(initialize(languages, { defaultLanguage: 'fr' }));", 
            "title": "2. Initialize languages"
        }, 
        {
            "location": "/getting-started/#3-add-translation-data", 
            "text": "Typically you will store your translation data in json files, but the data can also be a vanilla JS object.   In order to add translation data to your application there are two action creators available -  addTranslation  and  addTranslationForLanguage . Which one you use will depend on which format your translation data is in - see  formatting transaltion data  for more information.  \n   Note \n   The following assumes you are using  webpack  to bundle json    Multiple language format   import { addTranslation } from 'react-localize-redux';\n\nconst json = require('global.locale.json');\nstore.dispatch(addTranslation(json));   Single language format   import { addTranslationForLanguage } from 'react-localize-redux';\n\nconst json = require('en.json');\nstore.dispatch(addTranslationForLanguage(json, 'en'));", 
            "title": "3. Add translation data"
        }, 
        {
            "location": "/getting-started/#4-change-language", 
            "text": "Dispatch  setActiveLanguage  and pass the language.  import { setActiveLanguage } from 'react-localize-redux';\n\nstore.dispatch(setActiveLanguage('fr'));", 
            "title": "4. Change language"
        }, 
        {
            "location": "/getting-started/#5-translate-components", 
            "text": "If you have a component that is already using  connect  use  getTranslate  in your  mapStateToProps  to add the  translate  function to your component's props.  import { getTranslate } from 'react-localize-redux';\n\nconst Greeting = ({ translate, currentLanguage }) =  (\n   div \n     h1 { translate('greeting') } /h1 \n     button { translate('farwell') } /button \n   /div \n);\n\nconst mapStateToProps = state =  ({\n  translate: getTranslate(state.locale),\n  currentLanguage: getActiveLanguage(state.locale).code\n});\n\nexport default connect(mapStateToProps)(Greeting);  For components where you only need access to  translate  and  currentLanguage  you can use  localize . This will automatically connect your component with the  translate  function and  currentLanguage  prop.   \n   Warning \n   Components that use  localize  still use  connect  behind the scenes, which means you will want to avoid overusing  localize . Instead  pass multiple translations to components  when possible.   import { localize } from 'react-localize-redux';\n\nconst Greeting = ({ translate, currentLanguage }) =  (\n   div \n     h1 { translate('greeting') } /h1 \n     button { translate('farwell') } /button \n   /div \n);\n\nexport default localize(Greeting, 'locale');", 
            "title": "5. Translate components"
        }, 
        {
            "location": "/formatting-translation-data/", 
            "text": "The translation data for you application will either come from json or vanilla JS, but in order for \nreact-localize-redux\n to work with your data in needs to be in one of the following formats.\n\n\nMultiple language format\n\n\n\n\nUse \naddTranslation\n to add data in this format.\n\n\n\n\nThe data is an object where the property name is your translation key, and the value is an array of translations. The translation key is used to identify the translation, and the value is an array that enforces the following...\n\n\n\n\nIncludes a translation for each language your app supports.\n\n\nThe order of the translation strings in the array matters! The order \nMUST\n follow the order of the languages array passed to \nsetLanguages\n.\n\n\n\n\nAssuming your application has dispatched \nsetLanguages('en', 'fr', 'es')\n:\n\n\n{\n  \ngreeting\n: [\n    \nHello\n,      (en)\n    \nBonjour\n,    (fr)\n    \nHola\n,       (es)\n  ],\n  \nfarwell\n: [\n    \nGoodbye\n,    (en)\n    \nAu revoir\n,  (fr)\n    \nAdi\u00f3s\n       (es)\n  ]\n}\n\n\n\n\n\n\nSingle language format\n\n\n\n\nUse \naddTranslationForLanguage\n to add data in this format.\n\n\n\n\nThe data is an object where the property name is your translation key, and the value is the translation for the language. With the single language format you would dispatch \naddTranslationForLanguage\n for each language you support.\n\n\nAssuming your application \nsetLanguages('en', 'fr', 'es')\n:\n\n\n// en.json\n{\n  \ngreeting\n: \nHello\n,\n  \nfarwell\n: \nGoodbye\n\n}\n\n// fr.json\n{\n  \ngreeting\n:\nBonjour\n,\n  \nfarwell\n: \nAu revoir\n\n}\n\n// es.json\n{\n  \ngreeting\n: \nHola\n,\n  \nfarwell\n: \nAdi\u00f3s\n\n}\n\n\n\n\n\n\nNested data format\n\n\nBoth types of translation data support nested data format to help with organization of translations, and avoiding naming collisions with translation keys.\n\n\n Single language format \n\n\n{\n  \nwelcome\n {\n    \nbanner\n: {\n      \ngreeting\n: [\nHello\n, \nBonjour\n, \nHola\n]\n    },\n    \nfooter\n: {\n      \nfarwell\n: [\nGoodbye\n, \nAu revoir\n, \nAdi\u00f3s\n]\n    }\n  }\n}\n\n\n\n\n Multiple language format \n\n\n// en.json\n{\n  \nwelcome\n {\n    \nbanner\n: {\n      \ngreeting\n: \nHello\n\n    },\n    \nfooter\n: {\n      \nfarwell\n: \nGoodbye\n\n    }\n  }\n}\n\n// fr.json\n{\n  \nwelcome\n {\n    \nbanner\n: {\n      \ngreeting\n: \nBonjour\n\n    },\n    \nfooter\n: {\n      \nfarwell\n: \nAu revoir\n\n    }\n  }\n}\n\n// es.json\n{\n  \nwelcome\n {\n    \nbanner\n: {\n      \ngreeting\n: \nHola\n\n    },\n    \nfooter\n: {\n      \nfarwell\n: \nAdi\u00f3s\n\n    }\n  }\n}", 
            "title": "Formatting Translation Data"
        }, 
        {
            "location": "/formatting-translation-data/#multiple-language-format", 
            "text": "Use  addTranslation  to add data in this format.   The data is an object where the property name is your translation key, and the value is an array of translations. The translation key is used to identify the translation, and the value is an array that enforces the following...   Includes a translation for each language your app supports.  The order of the translation strings in the array matters! The order  MUST  follow the order of the languages array passed to  setLanguages .   Assuming your application has dispatched  setLanguages('en', 'fr', 'es') :  {\n   greeting : [\n     Hello ,      (en)\n     Bonjour ,    (fr)\n     Hola ,       (es)\n  ],\n   farwell : [\n     Goodbye ,    (en)\n     Au revoir ,  (fr)\n     Adi\u00f3s        (es)\n  ]\n}", 
            "title": "Multiple language format"
        }, 
        {
            "location": "/formatting-translation-data/#single-language-format", 
            "text": "Use  addTranslationForLanguage  to add data in this format.   The data is an object where the property name is your translation key, and the value is the translation for the language. With the single language format you would dispatch  addTranslationForLanguage  for each language you support.  Assuming your application  setLanguages('en', 'fr', 'es') :  // en.json\n{\n   greeting :  Hello ,\n   farwell :  Goodbye \n}\n\n// fr.json\n{\n   greeting : Bonjour ,\n   farwell :  Au revoir \n}\n\n// es.json\n{\n   greeting :  Hola ,\n   farwell :  Adi\u00f3s \n}", 
            "title": "Single language format"
        }, 
        {
            "location": "/formatting-translation-data/#nested-data-format", 
            "text": "Both types of translation data support nested data format to help with organization of translations, and avoiding naming collisions with translation keys.   Single language format   {\n   welcome  {\n     banner : {\n       greeting : [ Hello ,  Bonjour ,  Hola ]\n    },\n     footer : {\n       farwell : [ Goodbye ,  Au revoir ,  Adi\u00f3s ]\n    }\n  }\n}   Multiple language format   // en.json\n{\n   welcome  {\n     banner : {\n       greeting :  Hello \n    },\n     footer : {\n       farwell :  Goodbye \n    }\n  }\n}\n\n// fr.json\n{\n   welcome  {\n     banner : {\n       greeting :  Bonjour \n    },\n     footer : {\n       farwell :  Au revoir \n    }\n  }\n}\n\n// es.json\n{\n   welcome  {\n     banner : {\n       greeting :  Hola \n    },\n     footer : {\n       farwell :  Adi\u00f3s \n    }\n  }\n}", 
            "title": "Nested data format"
        }, 
        {
            "location": "/features/", 
            "text": "Pass multiple translations to components\n\n\nTo avoid connecting every single component that needs translations you should instead pass translations down to child components.\nTo retrieve multiple translations using \ntranslate\n pass an array of translation keys instead of a single key. This will return an object with translated strings mapped to translation keys.\n\n\nSince \ntranslate\n returns an object we can use the object spread operator to pass the translations as props for the \nArticle\n component.\n\n\nconst translationData = {\n  heading: [\nHeading\n, \nHeading French\n],\n  article: {\n    title: [\nTitle\n, \nTitle French\n],\n    author: [\nBy ${ name }\n, \nBy French ${ name }\n],\n    desc: [\nDescription\n, \nDescription French\n]\n  }\n};\n\nconst Page = ({ translate }) =\n (\n  \ndiv\n\n    \nh1\n{ translate('heading') }\n/h1\n\n    \nArticle { ...translate(['article.title', 'article.author', 'article.desc'], { name: 'Ted' }) } /\n\n  \n/div\n\n);\n\nconst Article = props =\n (\n  \ndiv\n\n    \nh2\n{ props['article.title'] }\n/h2\n\n    \nh3\n{ props['article.author'] }\n/h3\n\n    \np\n{ props['article.desc'] }\n/p\n\n  \n/div\n\n);\n\n\n\n\n\n\nInsert dynamic content into translations\n\n\nInsert dynamic content into your translation strings by inserting placeholders with the following format \n${ placeholder }\n.\n\n\n{\n  \ngreeting\n: [\n    \nHello ${ name }\n,\n    \nBonjour ${ name }\n\n  ]\n}\n\n\n\n\nThen pass in the data you want to swap in for placeholders to the \ntranslate\n function.\n\n\nh1\n{ translate('greeting', { name: 'Testy McTest' }) }\n/h1\n\n\n\n\n\n\n\nInclude HTML in translations\n\n\nInclude HTML in your translation strings and it will be rendered in your component.\n\n\n{\n  \ngoogle-link\n: [\n    \na href='https://www.google.en/'\nGoogle\n/a\n,\n    \na href='https://www.google.fr/'\nGoogle\n/a\n\n  ]\n}\n\n\n\n\n\n\nAvoid naming collisions with nested translation data\n\n\n Multiple language format \n\n\n{\n  \nwelcome\n: {\n    \ngreeting\n: [\n      \nHello ${ name }!\n,\n      \nBonjour ${ name }!\n\n    ]\n  },\n  \ninfo\n: {\n    \ngreeting\n: [\n      \nHello\n,\n      \nBonjour\n\n    ]\n  }\n}\n\n\n\n\n Single language format \n\n\n{\n  \nwelcome\n: {\n    \ngreeting\n: \nHello ${ name }!\n\n  },\n  \ninfo\n: {\n    \ngreeting\n: \nHello\n\n  }\n}\n\n\n\n\nh1\n{ translate('welcome.greeting', { name: 'Testy McTest' }) }\n/h1\n\n\nh1\n{ translate('info.greeting') }\n/h1\n\n\n\n\n\n\n\nLoad translation data on demand\n\n\nIf you have a larger app you may want to break your translation data up into multiple files, or maybe your translation data is being loaded from a service. You can call \naddTranslation\n for each new translation file/service, and the new translation data will be added to your Redux store.\n\n\nAlso If you are using a tool like \nwebpack\n for bundling, then you can use \nasync code-splitting\n to split translations across bundles, and async load them when you need them.", 
            "title": "Features"
        }, 
        {
            "location": "/features/#pass-multiple-translations-to-components", 
            "text": "To avoid connecting every single component that needs translations you should instead pass translations down to child components.\nTo retrieve multiple translations using  translate  pass an array of translation keys instead of a single key. This will return an object with translated strings mapped to translation keys.  Since  translate  returns an object we can use the object spread operator to pass the translations as props for the  Article  component.  const translationData = {\n  heading: [ Heading ,  Heading French ],\n  article: {\n    title: [ Title ,  Title French ],\n    author: [ By ${ name } ,  By French ${ name } ],\n    desc: [ Description ,  Description French ]\n  }\n};\n\nconst Page = ({ translate }) =  (\n   div \n     h1 { translate('heading') } /h1 \n     Article { ...translate(['article.title', 'article.author', 'article.desc'], { name: 'Ted' }) } / \n   /div \n);\n\nconst Article = props =  (\n   div \n     h2 { props['article.title'] } /h2 \n     h3 { props['article.author'] } /h3 \n     p { props['article.desc'] } /p \n   /div \n);", 
            "title": "Pass multiple translations to components"
        }, 
        {
            "location": "/features/#insert-dynamic-content-into-translations", 
            "text": "Insert dynamic content into your translation strings by inserting placeholders with the following format  ${ placeholder } .  {\n   greeting : [\n     Hello ${ name } ,\n     Bonjour ${ name } \n  ]\n}  Then pass in the data you want to swap in for placeholders to the  translate  function.  h1 { translate('greeting', { name: 'Testy McTest' }) } /h1", 
            "title": "Insert dynamic content into translations"
        }, 
        {
            "location": "/features/#include-html-in-translations", 
            "text": "Include HTML in your translation strings and it will be rendered in your component.  {\n   google-link : [\n     a href='https://www.google.en/' Google /a ,\n     a href='https://www.google.fr/' Google /a \n  ]\n}", 
            "title": "Include HTML in translations"
        }, 
        {
            "location": "/features/#avoid-naming-collisions-with-nested-translation-data", 
            "text": "Multiple language format   {\n   welcome : {\n     greeting : [\n       Hello ${ name }! ,\n       Bonjour ${ name }! \n    ]\n  },\n   info : {\n     greeting : [\n       Hello ,\n       Bonjour \n    ]\n  }\n}   Single language format   {\n   welcome : {\n     greeting :  Hello ${ name }! \n  },\n   info : {\n     greeting :  Hello \n  }\n}  h1 { translate('welcome.greeting', { name: 'Testy McTest' }) } /h1  h1 { translate('info.greeting') } /h1", 
            "title": "Avoid naming collisions with nested translation data"
        }, 
        {
            "location": "/features/#load-translation-data-on-demand", 
            "text": "If you have a larger app you may want to break your translation data up into multiple files, or maybe your translation data is being loaded from a service. You can call  addTranslation  for each new translation file/service, and the new translation data will be added to your Redux store.  Also If you are using a tool like  webpack  for bundling, then you can use  async code-splitting  to split translations across bundles, and async load them when you need them.", 
            "title": "Load translation data on demand"
        }, 
        {
            "location": "/api/action-creators/", 
            "text": "initialize(languages, [options])\n\n\nDispatch this action when your app is initialized, and pass in which languages you are supporting in your translations. An optional \noptions\n param can be passed to configure additional settings.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlanguages\n\n\nstring []\n\n\nAn array of languages codes\n\n\n\n\n\n\n[options]\n\n\nobject\n\n\nAdditional configuration options\n\n\n\n\n\n\n\n\n Options: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndefaultLanguage\n\n\nstring\n\n\nlanguages[0]\n\n\nAn array of languages codes\n\n\n\n\n\n\nrenderInnerHtml\n\n\nboolean\n\n\ntrue\n\n\nControls whether HTML in your translations will be rendered or returned as a plain string.\n\n\n\n\n\n\n\n\n\n  \nImportant\n\n  \nIf you're adding translation data from un-trusted sources make sure you set \nrenderInnerHtml\n option to \nfalse\n. In order to render HTML tags in translations react-localize-redux uses React's \ndangerouslySetInnerHTML\n, which has \nrisks\n when used improperly. For this reason in the next major release this option will be set to \nfalse\n by default to align with \ndangerouslySetInnerHTML\n.\n\n\n\n\n\n Usage: \n\n\nconst languages = ['en', 'fr', 'es'];\n\nstore.dispatch(initialize(languages));\n\n// if you wanted 'fr' to be default language instead of 'en'\nstore.dispatch(initialize(languages, { defaultLanguage: 'fr' }));\n\n\n\n\n\n\nsetLanguages(languages, [defaultActiveLanguage])\n\n\n\n  \nDeprecated\n\n  \nThis has been replaced by the \ninitialize\n action creator, and will be removed in the next major version.\n\n\n\n\n\nDispatch this action to set which languages you are supporting in your translations. If \ndefaultActiveLanguage\n is not passed then the first language in the \nlanguages\n array will be used.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlanguages\n\n\nstring []\n\n\nAn array of languages codes\n\n\n\n\n\n\n[defaultActiveLanguage]\n\n\nstring\n\n\nPass a language code to override the default active language.\n\n\n\n\n\n\n\n\n Usage: \n\n\nconst languages = ['en', 'fr', 'es'];\n\nstore.dispatch(setLanguages(languages));\n\n// if you wanted 'fr' to be default language instead of 'en'\nstore.dispatch(setLanguages(languages, 'fr'));\n\n\n\n\n\n\naddTranslation(data)\n\n\nDispatch this action to add translation data for multiple languages from a json file, or vanilla JS to your redux store. Please see \nformatting transaltion data\n to ensure your data is in the proper format. \n\n\n Arguments \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\njson | object\n\n\nTranslation data in the \nrequired format\n\n\n\n\n\n\n\n\n Usage: \n\n\n// assuming your app has set languages ['en', 'fr']\nconst welcomePageTranslations = {\n  greeting: ['Hi!', 'Bonjour!'],\n  farwell: ['Bye!', 'Au revoir!']\n};\n\nstore.dispatch(addTranslation(welcomePageTranslations));\n\n\n\n\n\n\naddTranslationForLanguage(data, language)\n\n\nDispatch this action to add translation data for a single language from a json file, or vanilla JS to your redux store. Please see \nformatting transaltion data\n to ensure your data is in the proper format. \n\n\n Arguments \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\njson | object\n\n\nTranslation data in the \nrequired format\n\n\n\n\n\n\nlanguage\n\n\nstring\n\n\nThe language code this translation data belongs to\n\n\n\n\n\n\n\n\n Usage: \n\n\n// assuming your app has set languages ['en', 'fr']\nconst welcomePageEnglish = {\n  greeting: 'Hi!',\n  farwell: 'Bye!'\n};\n\nstore.dispatch(addTranslationForLanguage(welcomePageEnglish, 'en'));\n\n\n\n\n\n\nsetActiveLanguage(language)\n\n\nRedux action creator\n to change the current language being used.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlanguage\n\n\nstring\n\n\nThe language code you want to set as active.\n\n\n\n\n\n\n\n\n Usage: \n\n\n// assuming your app has set languages ['en', 'fr']\nstore.dispatch(setActiveLanguage('fr'));", 
            "title": "Action Creators"
        }, 
        {
            "location": "/api/action-creators/#initializelanguages-options", 
            "text": "Dispatch this action when your app is initialized, and pass in which languages you are supporting in your translations. An optional  options  param can be passed to configure additional settings.   Arguments:      name  Type  Description      languages  string []  An array of languages codes    [options]  object  Additional configuration options      Options:      name  Type  Default  Description      defaultLanguage  string  languages[0]  An array of languages codes    renderInnerHtml  boolean  true  Controls whether HTML in your translations will be rendered or returned as a plain string.     \n   Important \n   If you're adding translation data from un-trusted sources make sure you set  renderInnerHtml  option to  false . In order to render HTML tags in translations react-localize-redux uses React's  dangerouslySetInnerHTML , which has  risks  when used improperly. For this reason in the next major release this option will be set to  false  by default to align with  dangerouslySetInnerHTML .    Usage:   const languages = ['en', 'fr', 'es'];\n\nstore.dispatch(initialize(languages));\n\n// if you wanted 'fr' to be default language instead of 'en'\nstore.dispatch(initialize(languages, { defaultLanguage: 'fr' }));", 
            "title": "initialize(languages, [options])"
        }, 
        {
            "location": "/api/action-creators/#setlanguageslanguages-defaultactivelanguage", 
            "text": "Deprecated \n   This has been replaced by the  initialize  action creator, and will be removed in the next major version.   Dispatch this action to set which languages you are supporting in your translations. If  defaultActiveLanguage  is not passed then the first language in the  languages  array will be used.   Arguments:      name  Type  Description      languages  string []  An array of languages codes    [defaultActiveLanguage]  string  Pass a language code to override the default active language.      Usage:   const languages = ['en', 'fr', 'es'];\n\nstore.dispatch(setLanguages(languages));\n\n// if you wanted 'fr' to be default language instead of 'en'\nstore.dispatch(setLanguages(languages, 'fr'));", 
            "title": "setLanguages(languages, [defaultActiveLanguage])"
        }, 
        {
            "location": "/api/action-creators/#addtranslationdata", 
            "text": "Dispatch this action to add translation data for multiple languages from a json file, or vanilla JS to your redux store. Please see  formatting transaltion data  to ensure your data is in the proper format.    Arguments      name  Type  Description      data  json | object  Translation data in the  required format      Usage:   // assuming your app has set languages ['en', 'fr']\nconst welcomePageTranslations = {\n  greeting: ['Hi!', 'Bonjour!'],\n  farwell: ['Bye!', 'Au revoir!']\n};\n\nstore.dispatch(addTranslation(welcomePageTranslations));", 
            "title": "addTranslation(data)"
        }, 
        {
            "location": "/api/action-creators/#addtranslationforlanguagedata-language", 
            "text": "Dispatch this action to add translation data for a single language from a json file, or vanilla JS to your redux store. Please see  formatting transaltion data  to ensure your data is in the proper format.    Arguments      name  Type  Description      data  json | object  Translation data in the  required format    language  string  The language code this translation data belongs to      Usage:   // assuming your app has set languages ['en', 'fr']\nconst welcomePageEnglish = {\n  greeting: 'Hi!',\n  farwell: 'Bye!'\n};\n\nstore.dispatch(addTranslationForLanguage(welcomePageEnglish, 'en'));", 
            "title": "addTranslationForLanguage(data, language)"
        }, 
        {
            "location": "/api/action-creators/#setactivelanguagelanguage", 
            "text": "Redux action creator  to change the current language being used.   Arguments:      name  Type  Description      language  string  The language code you want to set as active.      Usage:   // assuming your app has set languages ['en', 'fr']\nstore.dispatch(setActiveLanguage('fr'));", 
            "title": "setActiveLanguage(language)"
        }, 
        {
            "location": "/api/selectors/", 
            "text": "getTranslate(state)\n\n\nA selector that takes the localeReducer slice of your \nstate\n and returns the \ntranslate\n function. This function will have access to any and all translations that were added to your redux store.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstate\n\n\nany\n\n\nThe localeReducer slice of your state.\n\n\n\n\n\n\n\n\n Returns: \n\n\nReturns the \ntranslate\n function.\n\n\n Usage: \n\n\nconst Greeting = ({ translate }) =\n \nh1\n{ translate('greeting') }\n/h1\n\n\nconst mapStateToProps = state =\n ({ translate: getTranslate(state.locale) });\nexport default connect(mapStateToProps)(Greeting);\n\n\n\n\n\n\ntranslate(key: string | string[], [data], [options])\n\n\nThe \ngetTranslate\n selector will return the \ntranslate\n function, which is used to add localized strings to your connected React components. The translate function will return single, or multiple translations depending on the arguments passed. \n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nstring | string []\n\n\nPass a single key or multiple keys from your translation data.\n\n\n\n\n\n\n[data]\n\n\nobject\n\n\nOptional data to be used in your localized strings for \nvariable replacement\n.\n\n\n\n\n\n\n[options]\n\n\nobject\n\n\nOptional local override for \nrenderInnerHtml\n option passed to the \ninitialize\n action creator.\n\n\n\n\n\n\n\n\n Returns: \n\n\nIf a single key is passed then a single localized value will be returned in one of the following formats:\n\n\n\n\nif localized string contains HTML\n a \nReactElement\n will be returned.\n\n\nif localized string contains NO HTML\n a \nstring\n will be returned.\n\n\n\n\nIf multiple keys are passed then multiple localized values will be returned in the following format:\n\n\n{\n  'article.title': 'Article Title',\n  'article.author': 'Ted Tedson',\n  'article.desc': 'My awesome article description',\n  'article.code': '\ncode\nconsole.log(\nhi\n)\n/code\n'\n}\n\n\n\n\n Usage: \n\n\nconst Article = props =\n (\n  \ndiv\n\n    \nh2\n{ props['article.title'] }\n/h2\n\n    \nh3\n{ props['article.author'] }\n/h3\n\n    \np\n{ props['article.desc'] }\n/p\n\n  \n/div\n\n);\n\nconst Page = ({ translate }) =\n (\n  \ndiv\n\n    \nh1\n{ translate('heading') }\n/h1\n\n    \np\n{ translate('article.code', null, { renderInnerHtml: false }) }\n    \nArticle { ...translate(['article.title', 'article.author', 'article.desc'], { name: 'Ted' }) } /\n\n  \n/div\n\n);\n\nconst mapStateToProps = state =\n ({ translate: getTranslate(state.locale) });\nexport default connect(mapStateToProps)(Page);\n\n\n\n\n\n\ngetActiveLanguage(state)\n\n\nA selector that takes the localeReducer slice of your \nstate\n and returns the currently active language object.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstate\n\n\nany\n\n\nThe localeReducer slice of your state.\n\n\n\n\n\n\n\n\n Returns: \n\n\nThe active language object \n\n\n{ code: 'en', active: true }\n\n\n\n\n Usage: \n\n\nconst Greeting = ({ currentLanguage }) =\n \nh1\nMy language is: { currentLanguage }\n/h1\n\n\nconst mapStateToProps = state =\n ({ currentLanguage: getActiveLanguage(state.locale).code });\nexport default connect(mapStateToProps)(Greeting);\n\n\n\n\n\n\ngetLanguages(state)\n\n\nA selector that takes the localeReducer slice of your \nstate\n and returns the languages you set.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstate\n\n\nany\n\n\nThe localeReducer slice of your state.\n\n\n\n\n\n\n\n\n Returns: \n \n\n\nAn array of language codes \n\n\n[{ code: 'en', active: true }, { code: 'fr', active: false }]\n\n\n\n\n Usage: \n\n\nconst LanguageSelector = ({ languages }) =\n (\n  \nul\n\n    { languages.map(language =\n \n      \na onClick={ () =\n setActiveLanguage(language.code) }\n{ language.code }\n/a\n\n    )}\n  \n/ul\n\n);\n\nconst mapStateToProps = state =\n ({ languages: getLanguages(state.locale) });\nexport default connect(mapStateToProps, { setActiveLanguage })(Greeting);\n\n\n\n\n\n\ngetTranslations(state)\n\n\nA selector that takes your redux \nstate\n and returns all the translation data in your redux store.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstate\n\n\nany\n\n\nThe localeReducer slice of your state.\n\n\n\n\n\n\n\n\n Returns: \n \n\n\nAn object containing all your translation data.", 
            "title": "Selectors"
        }, 
        {
            "location": "/api/selectors/#gettranslatestate", 
            "text": "A selector that takes the localeReducer slice of your  state  and returns the  translate  function. This function will have access to any and all translations that were added to your redux store.   Arguments:      name  Type  Description      state  any  The localeReducer slice of your state.      Returns:   Returns the  translate  function.   Usage:   const Greeting = ({ translate }) =   h1 { translate('greeting') } /h1 \n\nconst mapStateToProps = state =  ({ translate: getTranslate(state.locale) });\nexport default connect(mapStateToProps)(Greeting);", 
            "title": "getTranslate(state)"
        }, 
        {
            "location": "/api/selectors/#translatekey-string-string-data-options", 
            "text": "The  getTranslate  selector will return the  translate  function, which is used to add localized strings to your connected React components. The translate function will return single, or multiple translations depending on the arguments passed.    Arguments:      name  Type  Description      key  string | string []  Pass a single key or multiple keys from your translation data.    [data]  object  Optional data to be used in your localized strings for  variable replacement .    [options]  object  Optional local override for  renderInnerHtml  option passed to the  initialize  action creator.      Returns:   If a single key is passed then a single localized value will be returned in one of the following formats:   if localized string contains HTML  a  ReactElement  will be returned.  if localized string contains NO HTML  a  string  will be returned.   If multiple keys are passed then multiple localized values will be returned in the following format:  {\n  'article.title': 'Article Title',\n  'article.author': 'Ted Tedson',\n  'article.desc': 'My awesome article description',\n  'article.code': ' code console.log( hi ) /code '\n}   Usage:   const Article = props =  (\n   div \n     h2 { props['article.title'] } /h2 \n     h3 { props['article.author'] } /h3 \n     p { props['article.desc'] } /p \n   /div \n);\n\nconst Page = ({ translate }) =  (\n   div \n     h1 { translate('heading') } /h1 \n     p { translate('article.code', null, { renderInnerHtml: false }) }\n     Article { ...translate(['article.title', 'article.author', 'article.desc'], { name: 'Ted' }) } / \n   /div \n);\n\nconst mapStateToProps = state =  ({ translate: getTranslate(state.locale) });\nexport default connect(mapStateToProps)(Page);", 
            "title": "translate(key: string | string[], [data], [options])"
        }, 
        {
            "location": "/api/selectors/#getactivelanguagestate", 
            "text": "A selector that takes the localeReducer slice of your  state  and returns the currently active language object.   Arguments:      name  Type  Description      state  any  The localeReducer slice of your state.      Returns:   The active language object   { code: 'en', active: true }   Usage:   const Greeting = ({ currentLanguage }) =   h1 My language is: { currentLanguage } /h1 \n\nconst mapStateToProps = state =  ({ currentLanguage: getActiveLanguage(state.locale).code });\nexport default connect(mapStateToProps)(Greeting);", 
            "title": "getActiveLanguage(state)"
        }, 
        {
            "location": "/api/selectors/#getlanguagesstate", 
            "text": "A selector that takes the localeReducer slice of your  state  and returns the languages you set.   Arguments:      name  Type  Description      state  any  The localeReducer slice of your state.      Returns:     An array of language codes   [{ code: 'en', active: true }, { code: 'fr', active: false }]   Usage:   const LanguageSelector = ({ languages }) =  (\n   ul \n    { languages.map(language =  \n       a onClick={ () =  setActiveLanguage(language.code) } { language.code } /a \n    )}\n   /ul \n);\n\nconst mapStateToProps = state =  ({ languages: getLanguages(state.locale) });\nexport default connect(mapStateToProps, { setActiveLanguage })(Greeting);", 
            "title": "getLanguages(state)"
        }, 
        {
            "location": "/api/selectors/#gettranslationsstate", 
            "text": "A selector that takes your redux  state  and returns all the translation data in your redux store.   Arguments:      name  Type  Description      state  any  The localeReducer slice of your state.      Returns:     An object containing all your translation data.", 
            "title": "getTranslations(state)"
        }, 
        {
            "location": "/api/higher-order-component/", 
            "text": "localize(Component, [reducerName])\n\n\n\n  \nImportant\n\n  \nif your component is already using \nconnect\n then you should use the \ngetTranslate\n, and \ngetActiveLanguage\n selectors instead of \nlocalize\n.\n\n\n\n\n\nIf you have a component that just needs access to translations, and nothing else then you can use the \nlocalize\n higher-order function. When you pass your Component to localize it will automatically add \ntranslate\n and \ncurrentLanguage\n to props. \n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nComponent\n\n\nReactComponent\n\n\nThe localeReducer slice of your state.\n\n\n\n\n\n\n[reducerName]\n\n\nstring\n\n\nIf you added localeReducer with \ncombineReducers\n then you will need to pass the reducerName to localize.\n\n\n\n\n\n\n\n\n Returns: \n \n\n\nA higher-order React component that adds \ntranslate\n and \ncurrentLanguage\n to props.\n\n\n Usage: \n\n\nconst Greeting = ({ translate, currentLanguage }) =\n (\n  \nspan\n\n    \nh1\nlanguageCode: { currentLanguage }\n/h1\n\n    \nh2\n{ translate('greeting', { name: 'Testy McTest' }) }\n/h2\n\n  \n/span\n\n);\nexport default localize(Greeting, 'locale');", 
            "title": "Higher Order Component"
        }, 
        {
            "location": "/api/higher-order-component/#localizecomponent-reducername", 
            "text": "Important \n   if your component is already using  connect  then you should use the  getTranslate , and  getActiveLanguage  selectors instead of  localize .   If you have a component that just needs access to translations, and nothing else then you can use the  localize  higher-order function. When you pass your Component to localize it will automatically add  translate  and  currentLanguage  to props.    Arguments:      name  Type  Description      Component  ReactComponent  The localeReducer slice of your state.    [reducerName]  string  If you added localeReducer with  combineReducers  then you will need to pass the reducerName to localize.      Returns:     A higher-order React component that adds  translate  and  currentLanguage  to props.   Usage:   const Greeting = ({ translate, currentLanguage }) =  (\n   span \n     h1 languageCode: { currentLanguage } /h1 \n     h2 { translate('greeting', { name: 'Testy McTest' }) } /h2 \n   /span \n);\nexport default localize(Greeting, 'locale');", 
            "title": "localize(Component, [reducerName])"
        }
    ]
}