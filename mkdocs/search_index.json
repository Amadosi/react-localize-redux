{
    "docs": [
        {
            "location": "/", 
            "text": "Localization library for \nReact\n/\nRedux\n.\n\n\n\n\n\n  \n\n  \n\n\n\n\n\nInstallation\n\n\nnpm install react-localize-redux --save", 
            "title": "Home"
        }, 
        {
            "location": "/#installation", 
            "text": "npm install react-localize-redux --save", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/", 
            "text": "1. Add reducer\n\n\n\n  \nNote\n\n  \nAlthough this example uses \nlocale\n for the reducer name, you can change this to a name of your choosing. Just ensure that you use your name when passing the state to selectors.\n\n\n\n\n\nimport { createStore, combineReducers } from 'redux';\nimport { user } from './reducers';\nimport { localeReducer as locale } from 'react-localize-redux';\n\nconst store = createStore(combineReducers({ user, locale }));\n\nconst App = props =\n {\n  return (\n    \nProvider store={ store }\n\n      ...\n    \n/Provider\n\n  );\n};\n\n\n\n\n\n\n2. Initialize languages\n\n\nDispatch \ninitialize\n action creator and pass in the languages for your app. By default the first language in the array will be set as the active language.\n\n\nimport { initialize } from 'react-localize-redux';\n\nconst languages = ['en', 'fr', 'es'];\nstore.dispatch(initialize(languages));\n\n\n\n\nTo set a different default active language set the \ndefaultLanguage\n option.\n\n\nconst languages = ['en', 'fr', 'es'];\nstore.dispatch(initialize(languages, { defaultLanguage: 'fr' }));\n\n\n\n\nIf you want to associate a language name with each language code you can use the following format:\n\n\nconst languages = [\n  { name: 'English', code: 'en' },\n  { name: 'French', code: 'fr' },\n  { name: 'Spanish', code: 'es' }\n];\nstore.dispatch(initialize(languages));\n\n\n\n\n\n\n3. Add translation data\n\n\nTypically you will store your translation data in json files, but the data can also be a vanilla JS object. \n\n\nIn order to add translation data to your application there are two action creators available - \naddTranslation\n and \naddTranslationForLanguage\n. Which one you use will depend on which format your translation data is in - see \nformatting translation data\n for more information.\n\n\n\n  \nNote\n\n  \nThe following assumes you are using \nwebpack\n to bundle json\n\n\n\n\n\n Multiple language format \n\n\nimport { addTranslation } from 'react-localize-redux';\n\nconst json = require('global.locale.json');\nstore.dispatch(addTranslation(json));\n\n\n\n\n Single language format \n\n\nimport { addTranslationForLanguage } from 'react-localize-redux';\n\nconst json = require('en.json');\nstore.dispatch(addTranslationForLanguage(json, 'en'));\n\n\n\n\n\n\n4. Change language\n\n\nDispatch \nsetActiveLanguage\n and pass the language.\n\n\nimport { setActiveLanguage } from 'react-localize-redux';\n\nstore.dispatch(setActiveLanguage('fr'));\n\n\n\n\n\n\n5. Translate components\n\n\nIf you have a component that is already using \nconnect\n use \ngetTranslate\n in your \nmapStateToProps\n to add the \ntranslate\n function to your component's props.\n\n\nimport { getTranslate, getActiveLanguage } from 'react-localize-redux';\n\nconst Greeting = ({ translate, currentLanguage }) =\n (\n  \ndiv\n\n    \nh1\n{ translate('greeting') }\n/h1\n\n    \nbutton\n{ translate('farwell') }\n/button\n\n  \n/div\n\n);\n\nconst mapStateToProps = state =\n ({\n  translate: getTranslate(state.locale),\n  currentLanguage: getActiveLanguage(state.locale).code\n});\n\nexport default connect(mapStateToProps)(Greeting);\n\n\n\n\nFor components where you only need access to \ntranslate\n and \ncurrentLanguage\n you can use \nlocalize\n. This will automatically connect your component with the \ntranslate\n function and \ncurrentLanguage\n prop. \n\n\n\n  \nWarning\n\n  \nComponents that use \nlocalize\n still use \nconnect\n behind the scenes, which means you will want to avoid overusing \nlocalize\n. Instead \npass multiple translations to components\n when possible.\n\n\n\n\n\nimport { localize } from 'react-localize-redux';\n\nconst Greeting = ({ translate, currentLanguage }) =\n (\n  \ndiv\n\n    \nh1\n{ translate('greeting') }\n/h1\n\n    \nbutton\n{ translate('farwell') }\n/button\n\n  \n/div\n\n);\n\nexport default localize(Greeting, 'locale');", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#1-add-reducer", 
            "text": "Note \n   Although this example uses  locale  for the reducer name, you can change this to a name of your choosing. Just ensure that you use your name when passing the state to selectors.   import { createStore, combineReducers } from 'redux';\nimport { user } from './reducers';\nimport { localeReducer as locale } from 'react-localize-redux';\n\nconst store = createStore(combineReducers({ user, locale }));\n\nconst App = props =  {\n  return (\n     Provider store={ store } \n      ...\n     /Provider \n  );\n};", 
            "title": "1. Add reducer"
        }, 
        {
            "location": "/getting-started/#2-initialize-languages", 
            "text": "Dispatch  initialize  action creator and pass in the languages for your app. By default the first language in the array will be set as the active language.  import { initialize } from 'react-localize-redux';\n\nconst languages = ['en', 'fr', 'es'];\nstore.dispatch(initialize(languages));  To set a different default active language set the  defaultLanguage  option.  const languages = ['en', 'fr', 'es'];\nstore.dispatch(initialize(languages, { defaultLanguage: 'fr' }));  If you want to associate a language name with each language code you can use the following format:  const languages = [\n  { name: 'English', code: 'en' },\n  { name: 'French', code: 'fr' },\n  { name: 'Spanish', code: 'es' }\n];\nstore.dispatch(initialize(languages));", 
            "title": "2. Initialize languages"
        }, 
        {
            "location": "/getting-started/#3-add-translation-data", 
            "text": "Typically you will store your translation data in json files, but the data can also be a vanilla JS object.   In order to add translation data to your application there are two action creators available -  addTranslation  and  addTranslationForLanguage . Which one you use will depend on which format your translation data is in - see  formatting translation data  for more information.  \n   Note \n   The following assumes you are using  webpack  to bundle json    Multiple language format   import { addTranslation } from 'react-localize-redux';\n\nconst json = require('global.locale.json');\nstore.dispatch(addTranslation(json));   Single language format   import { addTranslationForLanguage } from 'react-localize-redux';\n\nconst json = require('en.json');\nstore.dispatch(addTranslationForLanguage(json, 'en'));", 
            "title": "3. Add translation data"
        }, 
        {
            "location": "/getting-started/#4-change-language", 
            "text": "Dispatch  setActiveLanguage  and pass the language.  import { setActiveLanguage } from 'react-localize-redux';\n\nstore.dispatch(setActiveLanguage('fr'));", 
            "title": "4. Change language"
        }, 
        {
            "location": "/getting-started/#5-translate-components", 
            "text": "If you have a component that is already using  connect  use  getTranslate  in your  mapStateToProps  to add the  translate  function to your component's props.  import { getTranslate, getActiveLanguage } from 'react-localize-redux';\n\nconst Greeting = ({ translate, currentLanguage }) =  (\n   div \n     h1 { translate('greeting') } /h1 \n     button { translate('farwell') } /button \n   /div \n);\n\nconst mapStateToProps = state =  ({\n  translate: getTranslate(state.locale),\n  currentLanguage: getActiveLanguage(state.locale).code\n});\n\nexport default connect(mapStateToProps)(Greeting);  For components where you only need access to  translate  and  currentLanguage  you can use  localize . This will automatically connect your component with the  translate  function and  currentLanguage  prop.   \n   Warning \n   Components that use  localize  still use  connect  behind the scenes, which means you will want to avoid overusing  localize . Instead  pass multiple translations to components  when possible.   import { localize } from 'react-localize-redux';\n\nconst Greeting = ({ translate, currentLanguage }) =  (\n   div \n     h1 { translate('greeting') } /h1 \n     button { translate('farwell') } /button \n   /div \n);\n\nexport default localize(Greeting, 'locale');", 
            "title": "5. Translate components"
        }, 
        {
            "location": "/formatting-translation-data/", 
            "text": "The translation data for you application will either come from json or vanilla JS, but in order for \nreact-localize-redux\n to work with your data in needs to be in one of the following formats.\n\n\nMultiple language format\n\n\n\n\nUse \naddTranslation\n to add data in this format.\n\n\n\n\nThe data is an object where the property name is your translation key, and the value is an array of translations. The translation key is used to identify the translation, and the value is an array that enforces the following...\n\n\n\n\nIncludes a translation for each language your app supports.\n\n\nThe order of the translation strings in the array matters! The order \nMUST\n follow the order of the languages array passed to \nsetLanguages\n.\n\n\n\n\nAssuming your application has dispatched \nsetLanguages('en', 'fr', 'es')\n:\n\n\n{\n  \ngreeting\n: [\n    \nHello\n,      (en)\n    \nBonjour\n,    (fr)\n    \nHola\n,       (es)\n  ],\n  \nfarwell\n: [\n    \nGoodbye\n,    (en)\n    \nAu revoir\n,  (fr)\n    \nAdi\u00f3s\n       (es)\n  ]\n}\n\n\n\n\n\n\nSingle language format\n\n\n\n\nUse \naddTranslationForLanguage\n to add data in this format.\n\n\n\n\nThe data is an object where the property name is your translation key, and the value is the translation for the language. With the single language format you would dispatch \naddTranslationForLanguage\n for each language you support.\n\n\nAssuming your application \nsetLanguages('en', 'fr', 'es')\n:\n\n\n// en.json\n{\n  \ngreeting\n: \nHello\n,\n  \nfarwell\n: \nGoodbye\n\n}\n\n// fr.json\n{\n  \ngreeting\n:\nBonjour\n,\n  \nfarwell\n: \nAu revoir\n\n}\n\n// es.json\n{\n  \ngreeting\n: \nHola\n,\n  \nfarwell\n: \nAdi\u00f3s\n\n}\n\n\n\n\n\n\nCustom data format\n\n\nIf you cannot use the supported data formats there is a way to instruct react-localize-redux on how to handle your custom data. To do this you must pass the \ntranslationTransform\n option when dispatching the \nintialize\n action, which takes a function in the following format: \n\n\nconst transformationFunction = (translationData: Object, languagesCodes: string[]) =\n {\n  // Your transformation logic goes here...\n};\n\n\n\n\nThis function is responsible for taking your custom data, and transforming it into the format required by react-localize-redux. You are responsible for writing the transformation logic, but after that the function will be run automatically whenever dispatching \naddTranslation\n.\n\n\n\n  \nNote\n\n  \nThe transformation function will not be run if you use the \naddTranslationForLanguage\n action.\n\n\n\n\n\n Example \n\n\nFor example if you had data in the following format that you wanted to use...\n\n\nconst customTranslation = {\n  en: {\n    title: 'Title',\n    subtitle: 'Subtitle'\n  },\n  fr: {\n    title: 'FR - Title',\n    subtitle: 'FR - Subtitle'\n  }\n};\n\n\n\n\nYou would need to transform it into this format to work with react-localize-redux.\n\n\nconst translations = {\n  title: ['Title', 'FR - Title'],\n  subtitle: ['Subtitle', 'FR - Subtitle']\n};\n\n\n\n\nThis is where the transformation function comes in - we need to write a function that takes the custom translationData and returns the react-localize-redux format. Here is an example of what that function could look like for the example custom data:\n\n\nconst transformFunction = (translationData, languageCodes) =\n {\n  return Object.keys(translationData).reduce((prev, cur, index) =\n {\n    const languageData = data[cur];\n\n    for(let prop in languageData) {\n      const values = prev[prop] || [];\n      prev[prop] = languageCodes.map((code, languageIndex) =\n {\n        return index === languageIndex\n          ? languageData[prop]\n          : values[languageIndex];\n      })\n    }\n\n    return prev;\n  }, {});\n};\n\n\n\n\nNow when you dispatch the \nintialize\n action make sure you set the \ntranslationTransform\n option equal to the \ntransformFunction\n. Now anytime you dispatch the \naddTranslation\n action the \ntransformFunction\n will run on the translation data you are adding.\n\n\nconst languages = ['en', 'fr'];\nstore.dispatch(initialize(languages, { translationTransform: transformFunction }));\n\nstore.dispatch(addTranslation(customTranslation));\n\n\n\n\n\n\nNested data format\n\n\nBoth types of translation data support nested data format to help with organization of translations, and avoiding naming collisions with translation keys.\n\n\n Multiple language format \n\n\n{\n  \nwelcome\n {\n    \nbanner\n: {\n      \ngreeting\n: [\nHello\n, \nBonjour\n, \nHola\n]\n    },\n    \nfooter\n: {\n      \nfarwell\n: [\nGoodbye\n, \nAu revoir\n, \nAdi\u00f3s\n]\n    }\n  }\n}\n\n\n\n\n Single language format \n\n\n// en.json\n{\n  \nwelcome\n {\n    \nbanner\n: {\n      \ngreeting\n: \nHello\n\n    },\n    \nfooter\n: {\n      \nfarwell\n: \nGoodbye\n\n    }\n  }\n}\n\n// fr.json\n{\n  \nwelcome\n {\n    \nbanner\n: {\n      \ngreeting\n: \nBonjour\n\n    },\n    \nfooter\n: {\n      \nfarwell\n: \nAu revoir\n\n    }\n  }\n}\n\n// es.json\n{\n  \nwelcome\n {\n    \nbanner\n: {\n      \ngreeting\n: \nHola\n\n    },\n    \nfooter\n: {\n      \nfarwell\n: \nAdi\u00f3s\n\n    }\n  }\n}", 
            "title": "Formatting Translation Data"
        }, 
        {
            "location": "/formatting-translation-data/#multiple-language-format", 
            "text": "Use  addTranslation  to add data in this format.   The data is an object where the property name is your translation key, and the value is an array of translations. The translation key is used to identify the translation, and the value is an array that enforces the following...   Includes a translation for each language your app supports.  The order of the translation strings in the array matters! The order  MUST  follow the order of the languages array passed to  setLanguages .   Assuming your application has dispatched  setLanguages('en', 'fr', 'es') :  {\n   greeting : [\n     Hello ,      (en)\n     Bonjour ,    (fr)\n     Hola ,       (es)\n  ],\n   farwell : [\n     Goodbye ,    (en)\n     Au revoir ,  (fr)\n     Adi\u00f3s        (es)\n  ]\n}", 
            "title": "Multiple language format"
        }, 
        {
            "location": "/formatting-translation-data/#single-language-format", 
            "text": "Use  addTranslationForLanguage  to add data in this format.   The data is an object where the property name is your translation key, and the value is the translation for the language. With the single language format you would dispatch  addTranslationForLanguage  for each language you support.  Assuming your application  setLanguages('en', 'fr', 'es') :  // en.json\n{\n   greeting :  Hello ,\n   farwell :  Goodbye \n}\n\n// fr.json\n{\n   greeting : Bonjour ,\n   farwell :  Au revoir \n}\n\n// es.json\n{\n   greeting :  Hola ,\n   farwell :  Adi\u00f3s \n}", 
            "title": "Single language format"
        }, 
        {
            "location": "/formatting-translation-data/#custom-data-format", 
            "text": "If you cannot use the supported data formats there is a way to instruct react-localize-redux on how to handle your custom data. To do this you must pass the  translationTransform  option when dispatching the  intialize  action, which takes a function in the following format:   const transformationFunction = (translationData: Object, languagesCodes: string[]) =  {\n  // Your transformation logic goes here...\n};  This function is responsible for taking your custom data, and transforming it into the format required by react-localize-redux. You are responsible for writing the transformation logic, but after that the function will be run automatically whenever dispatching  addTranslation .  \n   Note \n   The transformation function will not be run if you use the  addTranslationForLanguage  action.    Example   For example if you had data in the following format that you wanted to use...  const customTranslation = {\n  en: {\n    title: 'Title',\n    subtitle: 'Subtitle'\n  },\n  fr: {\n    title: 'FR - Title',\n    subtitle: 'FR - Subtitle'\n  }\n};  You would need to transform it into this format to work with react-localize-redux.  const translations = {\n  title: ['Title', 'FR - Title'],\n  subtitle: ['Subtitle', 'FR - Subtitle']\n};  This is where the transformation function comes in - we need to write a function that takes the custom translationData and returns the react-localize-redux format. Here is an example of what that function could look like for the example custom data:  const transformFunction = (translationData, languageCodes) =  {\n  return Object.keys(translationData).reduce((prev, cur, index) =  {\n    const languageData = data[cur];\n\n    for(let prop in languageData) {\n      const values = prev[prop] || [];\n      prev[prop] = languageCodes.map((code, languageIndex) =  {\n        return index === languageIndex\n          ? languageData[prop]\n          : values[languageIndex];\n      })\n    }\n\n    return prev;\n  }, {});\n};  Now when you dispatch the  intialize  action make sure you set the  translationTransform  option equal to the  transformFunction . Now anytime you dispatch the  addTranslation  action the  transformFunction  will run on the translation data you are adding.  const languages = ['en', 'fr'];\nstore.dispatch(initialize(languages, { translationTransform: transformFunction }));\n\nstore.dispatch(addTranslation(customTranslation));", 
            "title": "Custom data format"
        }, 
        {
            "location": "/formatting-translation-data/#nested-data-format", 
            "text": "Both types of translation data support nested data format to help with organization of translations, and avoiding naming collisions with translation keys.   Multiple language format   {\n   welcome  {\n     banner : {\n       greeting : [ Hello ,  Bonjour ,  Hola ]\n    },\n     footer : {\n       farwell : [ Goodbye ,  Au revoir ,  Adi\u00f3s ]\n    }\n  }\n}   Single language format   // en.json\n{\n   welcome  {\n     banner : {\n       greeting :  Hello \n    },\n     footer : {\n       farwell :  Goodbye \n    }\n  }\n}\n\n// fr.json\n{\n   welcome  {\n     banner : {\n       greeting :  Bonjour \n    },\n     footer : {\n       farwell :  Au revoir \n    }\n  }\n}\n\n// es.json\n{\n   welcome  {\n     banner : {\n       greeting :  Hola \n    },\n     footer : {\n       farwell :  Adi\u00f3s \n    }\n  }\n}", 
            "title": "Nested data format"
        }, 
        {
            "location": "/features/", 
            "text": "Pass multiple translations to components\n\n\nTo avoid connecting every single component that needs translations you should instead pass translations down to child components.\nTo retrieve multiple translations using \ntranslate\n pass an array of translation keys instead of a single key. This will return an object with translated strings mapped to translation keys.\n\n\nSince \ntranslate\n returns an object we can use the object spread operator to pass the translations as props for the \nArticle\n component.\n\n\nconst translationData = {\n  heading: [\nHeading\n, \nHeading French\n],\n  article: {\n    title: [\nTitle\n, \nTitle French\n],\n    author: [\nBy ${ name }\n, \nBy French ${ name }\n],\n    desc: [\nDescription\n, \nDescription French\n]\n  }\n};\n\nconst Page = ({ translate }) =\n (\n  \ndiv\n\n    \nh1\n{ translate('heading') }\n/h1\n\n    \nArticle { ...translate(['article.title', 'article.author', 'article.desc'], { name: 'Ted' }) } /\n\n  \n/div\n\n);\n\nconst Article = props =\n (\n  \ndiv\n\n    \nh2\n{ props['article.title'] }\n/h2\n\n    \nh3\n{ props['article.author'] }\n/h3\n\n    \np\n{ props['article.desc'] }\n/p\n\n  \n/div\n\n);\n\n\n\n\n\n\nInsert dynamic content into translations\n\n\nInsert dynamic content into your translation strings by inserting placeholders with the following format \n${ placeholder }\n.\n\n\n{\n  \ngreeting\n: [\n    \nHello ${ name }\n,\n    \nBonjour ${ name }\n\n  ]\n}\n\n\n\n\nThen pass in the data you want to swap in for placeholders to the \ntranslate\n function.\n\n\nh1\n{ translate('greeting', { name: 'Testy McTest' }) }\n/h1\n\n\n\n\n\n\n\nInclude HTML in translations\n\n\nInclude HTML in your translation strings and it will be rendered in your component.\n\n\n{\n  \ngoogle-link\n: [\n    \na href='https://www.google.en/'\nGoogle\n/a\n,\n    \na href='https://www.google.fr/'\nGoogle\n/a\n\n  ]\n}\n\n\n\n\n\n\nHandle custom translation data\n\n\nDoes react-localize-redux's supported translation data formats not work for you? That's ok - there is a way for you to use your own custom trnaslation data format. See \nFormatting Transltion Data - Custom data format\n for full documentation.\n\n\n\n\nAvoid naming collisions with nested translation data\n\n\n Multiple language format \n\n\n{\n  \nwelcome\n: {\n    \ngreeting\n: [\n      \nHello ${ name }!\n,\n      \nBonjour ${ name }!\n\n    ]\n  },\n  \ninfo\n: {\n    \ngreeting\n: [\n      \nHello\n,\n      \nBonjour\n\n    ]\n  }\n}\n\n\n\n\n Single language format \n\n\n{\n  \nwelcome\n: {\n    \ngreeting\n: \nHello ${ name }!\n\n  },\n  \ninfo\n: {\n    \ngreeting\n: \nHello\n\n  }\n}\n\n\n\n\nh1\n{ translate('welcome.greeting', { name: 'Testy McTest' }) }\n/h1\n\n\nh1\n{ translate('info.greeting') }\n/h1\n\n\n\n\n\n\n\nCustom missing translation messages\n\n\nBy default when a translation isn't found the following message will be rendered in it's place: \n'Missing translation key ${ key } for language ${ code }'\n. Where \nkey\n will be the missing translation key, and \ncode\n will be the language code.\n\n\nYou can also override this message with a custom message by passing in your own \nmissingTranslationMsg\n option.\n\n\n Example \n\n\nimport { initialize } from 'react-localize-redux';\n\nconst languages = ['en', 'fr', 'es'];\n\n// just like the default message you can include the ${key} and ${code} placeholders\nconst missingTranslationMsg = 'Oh man you missed translation: ${key} for languge ${code}!';\n\nstore.dispatch(initialize(languages), { missingTranslationMsg });\n\n// Assuming there is no translation for \nmissing-key\n doesn't exist it would render following:\n// \nh1\nOh man you missed translation: missing-key for languge en!\n/h1\n\nconst MyComponent = props =\n \nh1\n{this.props.translate('missing-key')}\n/h1\n;\n\n// You also have the option to override the global missingTranslationMsg option\n// by passing a custom message directly to the translate function\n const missingTranslationMsg = 'Whoops! Missing translation!';\n const AnotherComponent = props =\n \nh1\n{this.props.translate('missing-key', null, { missingTranslationMsg })}\n/h1\n\n\n\n\n\n\n\nMissing translations callback\n\n\nIf you need a way to detect missing translations you can set the \nmissingTranslationCallback\n option. When set this callback will be triggered anytime the \ntranslate\n function detects an \nundefined\n translation.\n\n\n/**\n * The callback function will be called with the following arguments:\n * key - The key that was passed to the translate function\n * languageCode - The language code for the currently active language.\n */\nconst onMissingTranslation = (key, languageCode) =\n {\n  // here you can do whatever you want e.g. call back end service that will \n  // send email to translation team\n};\n\nstore.dispatch(initialize(languages), { missingTranslationCallback: onMissingTranslation });\n\n\n\n\n\n\nLoad translation data on demand\n\n\nIf you have a larger app you may want to break your translation data up into multiple files, or maybe your translation data is being loaded from a service. You can call \naddTranslation\n for each new translation file/service, and the new translation data will be added to your Redux store.\n\n\nAlso If you are using a tool like \nwebpack\n for bundling, then you can use \nasync code-splitting\n to split translations across bundles, and async load them when you need them.", 
            "title": "Features"
        }, 
        {
            "location": "/features/#pass-multiple-translations-to-components", 
            "text": "To avoid connecting every single component that needs translations you should instead pass translations down to child components.\nTo retrieve multiple translations using  translate  pass an array of translation keys instead of a single key. This will return an object with translated strings mapped to translation keys.  Since  translate  returns an object we can use the object spread operator to pass the translations as props for the  Article  component.  const translationData = {\n  heading: [ Heading ,  Heading French ],\n  article: {\n    title: [ Title ,  Title French ],\n    author: [ By ${ name } ,  By French ${ name } ],\n    desc: [ Description ,  Description French ]\n  }\n};\n\nconst Page = ({ translate }) =  (\n   div \n     h1 { translate('heading') } /h1 \n     Article { ...translate(['article.title', 'article.author', 'article.desc'], { name: 'Ted' }) } / \n   /div \n);\n\nconst Article = props =  (\n   div \n     h2 { props['article.title'] } /h2 \n     h3 { props['article.author'] } /h3 \n     p { props['article.desc'] } /p \n   /div \n);", 
            "title": "Pass multiple translations to components"
        }, 
        {
            "location": "/features/#insert-dynamic-content-into-translations", 
            "text": "Insert dynamic content into your translation strings by inserting placeholders with the following format  ${ placeholder } .  {\n   greeting : [\n     Hello ${ name } ,\n     Bonjour ${ name } \n  ]\n}  Then pass in the data you want to swap in for placeholders to the  translate  function.  h1 { translate('greeting', { name: 'Testy McTest' }) } /h1", 
            "title": "Insert dynamic content into translations"
        }, 
        {
            "location": "/features/#include-html-in-translations", 
            "text": "Include HTML in your translation strings and it will be rendered in your component.  {\n   google-link : [\n     a href='https://www.google.en/' Google /a ,\n     a href='https://www.google.fr/' Google /a \n  ]\n}", 
            "title": "Include HTML in translations"
        }, 
        {
            "location": "/features/#handle-custom-translation-data", 
            "text": "Does react-localize-redux's supported translation data formats not work for you? That's ok - there is a way for you to use your own custom trnaslation data format. See  Formatting Transltion Data - Custom data format  for full documentation.", 
            "title": "Handle custom translation data"
        }, 
        {
            "location": "/features/#avoid-naming-collisions-with-nested-translation-data", 
            "text": "Multiple language format   {\n   welcome : {\n     greeting : [\n       Hello ${ name }! ,\n       Bonjour ${ name }! \n    ]\n  },\n   info : {\n     greeting : [\n       Hello ,\n       Bonjour \n    ]\n  }\n}   Single language format   {\n   welcome : {\n     greeting :  Hello ${ name }! \n  },\n   info : {\n     greeting :  Hello \n  }\n}  h1 { translate('welcome.greeting', { name: 'Testy McTest' }) } /h1  h1 { translate('info.greeting') } /h1", 
            "title": "Avoid naming collisions with nested translation data"
        }, 
        {
            "location": "/features/#custom-missing-translation-messages", 
            "text": "By default when a translation isn't found the following message will be rendered in it's place:  'Missing translation key ${ key } for language ${ code }' . Where  key  will be the missing translation key, and  code  will be the language code.  You can also override this message with a custom message by passing in your own  missingTranslationMsg  option.   Example   import { initialize } from 'react-localize-redux';\n\nconst languages = ['en', 'fr', 'es'];\n\n// just like the default message you can include the ${key} and ${code} placeholders\nconst missingTranslationMsg = 'Oh man you missed translation: ${key} for languge ${code}!';\n\nstore.dispatch(initialize(languages), { missingTranslationMsg });\n\n// Assuming there is no translation for  missing-key  doesn't exist it would render following:\n//  h1 Oh man you missed translation: missing-key for languge en! /h1 \nconst MyComponent = props =   h1 {this.props.translate('missing-key')} /h1 ;\n\n// You also have the option to override the global missingTranslationMsg option\n// by passing a custom message directly to the translate function\n const missingTranslationMsg = 'Whoops! Missing translation!';\n const AnotherComponent = props =   h1 {this.props.translate('missing-key', null, { missingTranslationMsg })} /h1", 
            "title": "Custom missing translation messages"
        }, 
        {
            "location": "/features/#missing-translations-callback", 
            "text": "If you need a way to detect missing translations you can set the  missingTranslationCallback  option. When set this callback will be triggered anytime the  translate  function detects an  undefined  translation.  /**\n * The callback function will be called with the following arguments:\n * key - The key that was passed to the translate function\n * languageCode - The language code for the currently active language.\n */\nconst onMissingTranslation = (key, languageCode) =  {\n  // here you can do whatever you want e.g. call back end service that will \n  // send email to translation team\n};\n\nstore.dispatch(initialize(languages), { missingTranslationCallback: onMissingTranslation });", 
            "title": "Missing translations callback"
        }, 
        {
            "location": "/features/#load-translation-data-on-demand", 
            "text": "If you have a larger app you may want to break your translation data up into multiple files, or maybe your translation data is being loaded from a service. You can call  addTranslation  for each new translation file/service, and the new translation data will be added to your Redux store.  Also If you are using a tool like  webpack  for bundling, then you can use  async code-splitting  to split translations across bundles, and async load them when you need them.", 
            "title": "Load translation data on demand"
        }, 
        {
            "location": "/faq/", 
            "text": "Do I have to connect every component that needs translations?\n\n\nNo you shouldn't have to connect every component. To avoid this add translate to a parent component, and then pass translations \ndown to stateless child components as props. See the \npass multiple translations to components\n feature on one way to accomplish this.\n\n\n\n\nWhat if my translation data isn't in the required format?\n\n\nIf you don't have control over the translation data for your application you can use the \ntranslationTransform\n option. \nThis allows you to write a function that takes in your custom translation data, and outputs the data in the required format.\nSee \nCustom data format\n for documentaion.\n\n\n\n\nHow do I persist active language?\n\n\nPersisting the user\u2019s selected language  after a refresh can be done a few ways, and how that is done is really up to you. \nThe following are two approaches you could use:\n\n\n1. Save active language to local storage\n\n\nWhen you start your app check localstorage for an existing saved language. If one exists use that as default language, if not default to first language.\n\n\nconst languages = ['en', 'fr', 'es'];\nconst defaultLanguage = storage.getItem('language') || languages[0];\nstore.dispatch(initialize(languages, { defaultLanguage }));\n\n\n\n\nWhenever you change the active language update the language stored in localstorage.\n\n\nstore.dispatch(setActiveLanguage('fr'));\nstorage.setItem('language', 'fr');\n\n\n\n\n2. Keep active language in the url\n\n\nAssuming you're using \nreact-router\n you can use \nurl-params\n to track active language. Your url might look something like this, but the key is that it has the \n:language\n param. Now when you start your app use the url's language param, and set default language based on that.\n\n\nconst languages = ['en', 'fr', 'es'];\nconst defaultLanguage = this.props.match.params.language;\nstore.dispatch(initialize(languages, { defaultLanguage }));\n\n\n\n\n\n\nHow do I handle currency, date, and other localization transformations?\n\n\nThis logic is purposely excluded from react-localize-redux to ensure that both package size and API remian small. If you do require this logic you have the choice of writing it yourself, or using a third party library that specializes in that area e.g.(\nMoment\n for dates).\n\n\nHere's an example of a basic currency translation using \nreselect\n:\n\n\nimport { initialize } from 'react-localize-redux';\n\nconst languages = ['en', 'fr'];\n\nconst translations = {\n  currency: [\n$ ${value}\n, \n${value} $\n]\n};\n\nstore.dispatch(initialize(languages));\nstore.dispatch(addTranslation(translations));\n\nconst Transactions = ({translateCurrency}) =\n (\n  \nul\n\n    \nli\n{translateCurrency(1000)}\n/li\n     // renders $ 1,000 (en), 1 000 $ (fr)\n    \nli\n{translateCurrency(100000)}\n/li\n   // renders $ 100,000 (en), 100 000 $ (fr)\n    \nli\n{translateCurrency(500)}\n/li\n      // renders $ 500 (en), 500 $ (fr)\n  \n/ul\n\n);\n\nconst getTranslateSelector = (state) =\n getTranslate(state.locale);\nconst getActiveLanguageSelector = (state) =\n getActiveLanguage(state.locale);\n\n/**\n * Returns a function that takes a number, and formats it using\n * the current language, the currency translate data, and native toLocaleString \n */\nconst getTranslateCurrency = createSelector(\n  getTranslateSelector, getActiveLanguageSelector,\n  (translate, language) =\n (value) =\n {\n    const localizedValue = value.toLocaleString(language.code);\n    return translate('currency', {value: localizedValue});\n  }\n);\n\nconst mapStateToProps = state =\n ({\n  translateCurrency: getTranslateCurrency(state)\n});\n\nconst LocalizedTransactions = connect(mapStateToProps)(Transactions);\n\n\n\n\n\n\nHow does react-localize-redux differ from \nreact-intl\n?\n\n\n\n\nreact-intl\n is larger in size/complexity, and for good reason as it handles many things related to localization. e.g. Pluralization, currency. Where as with \nreact-localize-redux\n you could still do pluralization, and currency, but you'd be writing the formatting functionality yourself. \n\n\n\n\n\nreact-intl\n doesn't work with Redux out of the box, and needs an additional library \nreact-intl-redux\n to add support.\n\n\n\n\n\nFor further discussion on this topic see \noriginal github issue\n.", 
            "title": "FAQ"
        }, 
        {
            "location": "/faq/#do-i-have-to-connect-every-component-that-needs-translations", 
            "text": "No you shouldn't have to connect every component. To avoid this add translate to a parent component, and then pass translations \ndown to stateless child components as props. See the  pass multiple translations to components  feature on one way to accomplish this.", 
            "title": "Do I have to connect every component that needs translations?"
        }, 
        {
            "location": "/faq/#what-if-my-translation-data-isnt-in-the-required-format", 
            "text": "If you don't have control over the translation data for your application you can use the  translationTransform  option. \nThis allows you to write a function that takes in your custom translation data, and outputs the data in the required format.\nSee  Custom data format  for documentaion.", 
            "title": "What if my translation data isn't in the required format?"
        }, 
        {
            "location": "/faq/#how-do-i-persist-active-language", 
            "text": "Persisting the user\u2019s selected language  after a refresh can be done a few ways, and how that is done is really up to you. \nThe following are two approaches you could use:  1. Save active language to local storage  When you start your app check localstorage for an existing saved language. If one exists use that as default language, if not default to first language.  const languages = ['en', 'fr', 'es'];\nconst defaultLanguage = storage.getItem('language') || languages[0];\nstore.dispatch(initialize(languages, { defaultLanguage }));  Whenever you change the active language update the language stored in localstorage.  store.dispatch(setActiveLanguage('fr'));\nstorage.setItem('language', 'fr');  2. Keep active language in the url  Assuming you're using  react-router  you can use  url-params  to track active language. Your url might look something like this, but the key is that it has the  :language  param. Now when you start your app use the url's language param, and set default language based on that.  const languages = ['en', 'fr', 'es'];\nconst defaultLanguage = this.props.match.params.language;\nstore.dispatch(initialize(languages, { defaultLanguage }));", 
            "title": "How do I persist active language?"
        }, 
        {
            "location": "/faq/#how-do-i-handle-currency-date-and-other-localization-transformations", 
            "text": "This logic is purposely excluded from react-localize-redux to ensure that both package size and API remian small. If you do require this logic you have the choice of writing it yourself, or using a third party library that specializes in that area e.g.( Moment  for dates).  Here's an example of a basic currency translation using  reselect :  import { initialize } from 'react-localize-redux';\n\nconst languages = ['en', 'fr'];\n\nconst translations = {\n  currency: [ $ ${value} ,  ${value} $ ]\n};\n\nstore.dispatch(initialize(languages));\nstore.dispatch(addTranslation(translations));\n\nconst Transactions = ({translateCurrency}) =  (\n   ul \n     li {translateCurrency(1000)} /li      // renders $ 1,000 (en), 1 000 $ (fr)\n     li {translateCurrency(100000)} /li    // renders $ 100,000 (en), 100 000 $ (fr)\n     li {translateCurrency(500)} /li       // renders $ 500 (en), 500 $ (fr)\n   /ul \n);\n\nconst getTranslateSelector = (state) =  getTranslate(state.locale);\nconst getActiveLanguageSelector = (state) =  getActiveLanguage(state.locale);\n\n/**\n * Returns a function that takes a number, and formats it using\n * the current language, the currency translate data, and native toLocaleString \n */\nconst getTranslateCurrency = createSelector(\n  getTranslateSelector, getActiveLanguageSelector,\n  (translate, language) =  (value) =  {\n    const localizedValue = value.toLocaleString(language.code);\n    return translate('currency', {value: localizedValue});\n  }\n);\n\nconst mapStateToProps = state =  ({\n  translateCurrency: getTranslateCurrency(state)\n});\n\nconst LocalizedTransactions = connect(mapStateToProps)(Transactions);", 
            "title": "How do I handle currency, date, and other localization transformations?"
        }, 
        {
            "location": "/faq/#how-does-react-localize-redux-differ-from-react-intl", 
            "text": "react-intl  is larger in size/complexity, and for good reason as it handles many things related to localization. e.g. Pluralization, currency. Where as with  react-localize-redux  you could still do pluralization, and currency, but you'd be writing the formatting functionality yourself.    react-intl  doesn't work with Redux out of the box, and needs an additional library  react-intl-redux  to add support.   For further discussion on this topic see  original github issue .", 
            "title": "How does react-localize-redux differ from react-intl?"
        }, 
        {
            "location": "/api/action-creators/", 
            "text": "initialize(languages, [options])\n\n\nDispatch this action when your app is initialized, and pass in which languages you are supporting in your translations. An optional \noptions\n param can be passed to configure additional settings.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlanguages\n\n\nstring [] or \n{ name: string, code: string } []\n\n\nAn array of language codes or named language objects.\n\n\n\n\n\n\n[options]\n\n\nobject\n\n\nAdditional configuration options\n\n\n\n\n\n\n\n\n Options: \n\n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndefaultLanguage\n\n\nstring\n\n\nlanguages[0]\n\n\nThe language code for the language you'd like to set as the defualt.\n\n\n\n\n\n\nrenderInnerHtml\n\n\nboolean\n\n\ntrue\n\n\nControls whether HTML in your translations will be rendered or returned as a plain string.\n\n\n\n\n\n\nshowMissingTranslationMsg\n\n\nboolean\n\n\ntrue\n\n\nControls whether missing translation message will be rendered when translation is undefined.\n\n\n\n\n\n\nmissingTranslationMsg\n\n\nstring\n\n\nMissing translation key ${key} for language ${code}\n\n\nA message that will be rendered in place of missing translations\n\n\n\n\n\n\nmissingTranslationCallback\n\n\nfunction\n\n\nundefined\n\n\nA function that will be called when attempting to get an undefined translation. See \nHandle missing translations\n for details.\n\n\n\n\n\n\ntranslationTransform\n\n\nfunction\n\n\nundefined\n\n\nA transformation function that will be applied to translation data. See \nCustom data format\n for details.\n\n\n\n\n\n\n\n\n\n  \nDeprecated\n\n  \nshowMissingTranslationMsg\n - will be deprecated in the next major release, as you can set \nmissingTranslationMsg= ''\n  to accomplish the same thing as \nshowMissingTranslationMsg=false\n.\n\n\n\n\n\n\n  \nImportant\n\n  \nIf you're adding translation data from un-trusted sources make sure you set \nrenderInnerHtml\n option to \nfalse\n. In order to render HTML tags in translations react-localize-redux uses React's \ndangerouslySetInnerHTML\n, which has \nrisks\n when used improperly. For this reason in the next major release this option will be set to \nfalse\n by default to align with \ndangerouslySetInnerHTML\n.\n\n\n\n\n\n Usage: \n\n\n// with named languages \nconst languages = [\n  { name: 'English', code: 'en' },\n  { name: 'French', code: 'fr' },\n  { name: 'Spanish', code: 'es' }\n];\nstore.dispatch(initialize(languages));\n\n// with language codes only\nconst languages = ['en', 'fr', 'es'];\nstore.dispatch(initialize(languages));\n\n// if you wanted 'fr' to be default language instead of 'en'\nstore.dispatch(initialize(languages, { defaultLanguage: 'fr' }));\n\n\n\n\n\n\nsetLanguages(languages, [defaultActiveLanguage])\n\n\n\n  \nDeprecated\n\n  \nThis has been replaced by the \ninitialize\n action creator, and will be removed in the next major version.\n\n\n\n\n\nDispatch this action to set which languages you are supporting in your translations. If \ndefaultActiveLanguage\n is not passed then the first language in the \nlanguages\n array will be used.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlanguages\n\n\nstring []\n\n\nAn array of languages codes\n\n\n\n\n\n\n[defaultActiveLanguage]\n\n\nstring\n\n\nPass a language code to override the default active language.\n\n\n\n\n\n\n\n\n Usage: \n\n\nconst languages = ['en', 'fr', 'es'];\n\nstore.dispatch(setLanguages(languages));\n\n// if you wanted 'fr' to be default language instead of 'en'\nstore.dispatch(setLanguages(languages, 'fr'));\n\n\n\n\n\n\naddTranslation(data)\n\n\nDispatch this action to add translation data for multiple languages from a json file, or vanilla JS to your redux store. Please see \nformatting translation data\n to ensure your data is in the proper format. \n\n\n Arguments \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\njson | object\n\n\nTranslation data in the \nrequired format\n\n\n\n\n\n\n\n\n Usage: \n\n\n// assuming your app has set languages ['en', 'fr']\nconst welcomePageTranslations = {\n  greeting: ['Hi!', 'Bonjour!'],\n  farwell: ['Bye!', 'Au revoir!']\n};\n\nstore.dispatch(addTranslation(welcomePageTranslations));\n\n\n\n\n\n\naddTranslationForLanguage(data, language)\n\n\nDispatch this action to add translation data for a single language from a json file, or vanilla JS to your redux store. Please see \nformatting translation data\n to ensure your data is in the proper format. \n\n\n Arguments \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndata\n\n\njson | object\n\n\nTranslation data in the \nrequired format\n\n\n\n\n\n\nlanguage\n\n\nstring\n\n\nThe language code this translation data belongs to\n\n\n\n\n\n\n\n\n Usage: \n\n\n// assuming your app has set languages ['en', 'fr']\nconst welcomePageEnglish = {\n  greeting: 'Hi!',\n  farwell: 'Bye!'\n};\n\nstore.dispatch(addTranslationForLanguage(welcomePageEnglish, 'en'));\n\n\n\n\n\n\nsetActiveLanguage(language)\n\n\nRedux action creator\n to change the current language being used.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlanguage\n\n\nstring\n\n\nThe language code you want to set as active.\n\n\n\n\n\n\n\n\n Usage: \n\n\n// assuming your app has set languages ['en', 'fr']\nstore.dispatch(setActiveLanguage('fr'));", 
            "title": "Action Creators"
        }, 
        {
            "location": "/api/action-creators/#initializelanguages-options", 
            "text": "Dispatch this action when your app is initialized, and pass in which languages you are supporting in your translations. An optional  options  param can be passed to configure additional settings.   Arguments:      name  Type  Description      languages  string [] or  { name: string, code: string } []  An array of language codes or named language objects.    [options]  object  Additional configuration options      Options:      name  Type  Default  Description      defaultLanguage  string  languages[0]  The language code for the language you'd like to set as the defualt.    renderInnerHtml  boolean  true  Controls whether HTML in your translations will be rendered or returned as a plain string.    showMissingTranslationMsg  boolean  true  Controls whether missing translation message will be rendered when translation is undefined.    missingTranslationMsg  string  Missing translation key ${key} for language ${code}  A message that will be rendered in place of missing translations    missingTranslationCallback  function  undefined  A function that will be called when attempting to get an undefined translation. See  Handle missing translations  for details.    translationTransform  function  undefined  A transformation function that will be applied to translation data. See  Custom data format  for details.     \n   Deprecated \n   showMissingTranslationMsg  - will be deprecated in the next major release, as you can set  missingTranslationMsg= ''   to accomplish the same thing as  showMissingTranslationMsg=false .   \n   Important \n   If you're adding translation data from un-trusted sources make sure you set  renderInnerHtml  option to  false . In order to render HTML tags in translations react-localize-redux uses React's  dangerouslySetInnerHTML , which has  risks  when used improperly. For this reason in the next major release this option will be set to  false  by default to align with  dangerouslySetInnerHTML .    Usage:   // with named languages \nconst languages = [\n  { name: 'English', code: 'en' },\n  { name: 'French', code: 'fr' },\n  { name: 'Spanish', code: 'es' }\n];\nstore.dispatch(initialize(languages));\n\n// with language codes only\nconst languages = ['en', 'fr', 'es'];\nstore.dispatch(initialize(languages));\n\n// if you wanted 'fr' to be default language instead of 'en'\nstore.dispatch(initialize(languages, { defaultLanguage: 'fr' }));", 
            "title": "initialize(languages, [options])"
        }, 
        {
            "location": "/api/action-creators/#setlanguageslanguages-defaultactivelanguage", 
            "text": "Deprecated \n   This has been replaced by the  initialize  action creator, and will be removed in the next major version.   Dispatch this action to set which languages you are supporting in your translations. If  defaultActiveLanguage  is not passed then the first language in the  languages  array will be used.   Arguments:      name  Type  Description      languages  string []  An array of languages codes    [defaultActiveLanguage]  string  Pass a language code to override the default active language.      Usage:   const languages = ['en', 'fr', 'es'];\n\nstore.dispatch(setLanguages(languages));\n\n// if you wanted 'fr' to be default language instead of 'en'\nstore.dispatch(setLanguages(languages, 'fr'));", 
            "title": "setLanguages(languages, [defaultActiveLanguage])"
        }, 
        {
            "location": "/api/action-creators/#addtranslationdata", 
            "text": "Dispatch this action to add translation data for multiple languages from a json file, or vanilla JS to your redux store. Please see  formatting translation data  to ensure your data is in the proper format.    Arguments      name  Type  Description      data  json | object  Translation data in the  required format      Usage:   // assuming your app has set languages ['en', 'fr']\nconst welcomePageTranslations = {\n  greeting: ['Hi!', 'Bonjour!'],\n  farwell: ['Bye!', 'Au revoir!']\n};\n\nstore.dispatch(addTranslation(welcomePageTranslations));", 
            "title": "addTranslation(data)"
        }, 
        {
            "location": "/api/action-creators/#addtranslationforlanguagedata-language", 
            "text": "Dispatch this action to add translation data for a single language from a json file, or vanilla JS to your redux store. Please see  formatting translation data  to ensure your data is in the proper format.    Arguments      name  Type  Description      data  json | object  Translation data in the  required format    language  string  The language code this translation data belongs to      Usage:   // assuming your app has set languages ['en', 'fr']\nconst welcomePageEnglish = {\n  greeting: 'Hi!',\n  farwell: 'Bye!'\n};\n\nstore.dispatch(addTranslationForLanguage(welcomePageEnglish, 'en'));", 
            "title": "addTranslationForLanguage(data, language)"
        }, 
        {
            "location": "/api/action-creators/#setactivelanguagelanguage", 
            "text": "Redux action creator  to change the current language being used.   Arguments:      name  Type  Description      language  string  The language code you want to set as active.      Usage:   // assuming your app has set languages ['en', 'fr']\nstore.dispatch(setActiveLanguage('fr'));", 
            "title": "setActiveLanguage(language)"
        }, 
        {
            "location": "/api/selectors/", 
            "text": "getTranslate(state)\n\n\nA selector that takes the localeReducer slice of your \nstate\n and returns the \ntranslate\n function. This function will have access to any and all translations that were added to your redux store.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstate\n\n\nany\n\n\nThe localeReducer slice of your state.\n\n\n\n\n\n\n\n\n Returns: \n\n\nReturns the \ntranslate\n function.\n\n\n Usage: \n\n\nconst Greeting = ({ translate }) =\n \nh1\n{ translate('greeting') }\n/h1\n\n\nconst mapStateToProps = state =\n ({ translate: getTranslate(state.locale) });\nexport default connect(mapStateToProps)(Greeting);\n\n\n\n\n\n\ntranslate(key: string | string[], [data], [options])\n\n\nThe \ngetTranslate\n selector will return the \ntranslate\n function, which is used to add localized strings to your connected React components. The translate function will return single, or multiple translations depending on the arguments passed. \n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nkey\n\n\nstring | string []\n\n\nPass a single key or multiple keys from your translation data.\n\n\n\n\n\n\n[data]\n\n\nobject\n\n\nOptional data to be used in your localized strings for \nvariable replacement\n.\n\n\n\n\n\n\n[options]\n\n\nobject\n\n\nOptional local override for \nrenderInnerHtml\n option passed to the \ninitialize\n action creator.\n\n\n\n\n\n\n\n\n Returns: \n\n\nIf a single key is passed then a single localized value will be returned in one of the following formats:\n\n\n\n\nif localized string contains HTML\n a \nReactElement\n will be returned.\n\n\nif localized string contains NO HTML\n a \nstring\n will be returned.\n\n\n\n\nIf multiple keys are passed then multiple localized values will be returned in the following format:\n\n\n{\n  'article.title': 'Article Title',\n  'article.author': 'Ted Tedson',\n  'article.desc': 'My awesome article description',\n  'article.code': '\ncode\nconsole.log(\nhi\n)\n/code\n'\n}\n\n\n\n\n Usage: \n\n\nconst Article = props =\n (\n  \ndiv\n\n    \nh2\n{ props['article.title'] }\n/h2\n\n    \nh3\n{ props['article.author'] }\n/h3\n\n    \np\n{ props['article.desc'] }\n/p\n\n  \n/div\n\n);\n\nconst Page = ({ translate }) =\n (\n  \ndiv\n\n    \nh1\n{ translate('heading') }\n/h1\n\n    \np\n{ translate('article.code', null, { renderInnerHtml: false }) }\n    \nArticle { ...translate(['article.title', 'article.author', 'article.desc'], { name: 'Ted' }) } /\n\n  \n/div\n\n);\n\nconst mapStateToProps = state =\n ({ translate: getTranslate(state.locale) });\nexport default connect(mapStateToProps)(Page);\n\n\n\n\n\n\ngetActiveLanguage(state)\n\n\nA selector that takes the localeReducer slice of your \nstate\n and returns the currently active language object.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstate\n\n\nany\n\n\nThe localeReducer slice of your state.\n\n\n\n\n\n\n\n\n Returns: \n\n\nThe active language object \n\n\n{ name: 'English', code: 'en', active: true }\n\n\n\n\n Usage: \n\n\nconst Greeting = ({ currentLanguage }) =\n \nh1\nMy language is: { currentLanguage }\n/h1\n\n\nconst mapStateToProps = state =\n ({ currentLanguage: getActiveLanguage(state.locale).code });\nexport default connect(mapStateToProps)(Greeting);\n\n\n\n\n\n\ngetLanguages(state)\n\n\nA selector that takes the localeReducer slice of your \nstate\n and returns the languages you set.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstate\n\n\nany\n\n\nThe localeReducer slice of your state.\n\n\n\n\n\n\n\n\n Returns: \n \n\n\nAn array of language codes \n\n\n[{ name: 'English', code: 'en', active: true }, { name: 'French', code: 'fr', active: false }]\n\n\n\n\n Usage: \n\n\nconst LanguageSelector = ({ languages }) =\n (\n  \nul\n\n    { languages.map(language =\n (\n      \na onClick={ () =\n { setActiveLanguage(language.code) }\n{ language.name }\n/a\n\n    )}\n  \n/ul\n\n);\n\nconst mapStateToProps = state =\n ({ languages: getLanguages(state.locale) });\nexport default connect(mapStateToProps, { setActiveLanguage })(Greeting);\n\n\n\n\n\n\ngetTranslations(state)\n\n\nA selector that takes your redux \nstate\n and returns all the translation data in your redux store.\n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstate\n\n\nany\n\n\nThe localeReducer slice of your state.\n\n\n\n\n\n\n\n\n Returns: \n \n\n\nAn object containing all your translation data.", 
            "title": "Selectors"
        }, 
        {
            "location": "/api/selectors/#gettranslatestate", 
            "text": "A selector that takes the localeReducer slice of your  state  and returns the  translate  function. This function will have access to any and all translations that were added to your redux store.   Arguments:      name  Type  Description      state  any  The localeReducer slice of your state.      Returns:   Returns the  translate  function.   Usage:   const Greeting = ({ translate }) =   h1 { translate('greeting') } /h1 \n\nconst mapStateToProps = state =  ({ translate: getTranslate(state.locale) });\nexport default connect(mapStateToProps)(Greeting);", 
            "title": "getTranslate(state)"
        }, 
        {
            "location": "/api/selectors/#translatekey-string-string-data-options", 
            "text": "The  getTranslate  selector will return the  translate  function, which is used to add localized strings to your connected React components. The translate function will return single, or multiple translations depending on the arguments passed.    Arguments:      name  Type  Description      key  string | string []  Pass a single key or multiple keys from your translation data.    [data]  object  Optional data to be used in your localized strings for  variable replacement .    [options]  object  Optional local override for  renderInnerHtml  option passed to the  initialize  action creator.      Returns:   If a single key is passed then a single localized value will be returned in one of the following formats:   if localized string contains HTML  a  ReactElement  will be returned.  if localized string contains NO HTML  a  string  will be returned.   If multiple keys are passed then multiple localized values will be returned in the following format:  {\n  'article.title': 'Article Title',\n  'article.author': 'Ted Tedson',\n  'article.desc': 'My awesome article description',\n  'article.code': ' code console.log( hi ) /code '\n}   Usage:   const Article = props =  (\n   div \n     h2 { props['article.title'] } /h2 \n     h3 { props['article.author'] } /h3 \n     p { props['article.desc'] } /p \n   /div \n);\n\nconst Page = ({ translate }) =  (\n   div \n     h1 { translate('heading') } /h1 \n     p { translate('article.code', null, { renderInnerHtml: false }) }\n     Article { ...translate(['article.title', 'article.author', 'article.desc'], { name: 'Ted' }) } / \n   /div \n);\n\nconst mapStateToProps = state =  ({ translate: getTranslate(state.locale) });\nexport default connect(mapStateToProps)(Page);", 
            "title": "translate(key: string | string[], [data], [options])"
        }, 
        {
            "location": "/api/selectors/#getactivelanguagestate", 
            "text": "A selector that takes the localeReducer slice of your  state  and returns the currently active language object.   Arguments:      name  Type  Description      state  any  The localeReducer slice of your state.      Returns:   The active language object   { name: 'English', code: 'en', active: true }   Usage:   const Greeting = ({ currentLanguage }) =   h1 My language is: { currentLanguage } /h1 \n\nconst mapStateToProps = state =  ({ currentLanguage: getActiveLanguage(state.locale).code });\nexport default connect(mapStateToProps)(Greeting);", 
            "title": "getActiveLanguage(state)"
        }, 
        {
            "location": "/api/selectors/#getlanguagesstate", 
            "text": "A selector that takes the localeReducer slice of your  state  and returns the languages you set.   Arguments:      name  Type  Description      state  any  The localeReducer slice of your state.      Returns:     An array of language codes   [{ name: 'English', code: 'en', active: true }, { name: 'French', code: 'fr', active: false }]   Usage:   const LanguageSelector = ({ languages }) =  (\n   ul \n    { languages.map(language =  (\n       a onClick={ () =  { setActiveLanguage(language.code) } { language.name } /a \n    )}\n   /ul \n);\n\nconst mapStateToProps = state =  ({ languages: getLanguages(state.locale) });\nexport default connect(mapStateToProps, { setActiveLanguage })(Greeting);", 
            "title": "getLanguages(state)"
        }, 
        {
            "location": "/api/selectors/#gettranslationsstate", 
            "text": "A selector that takes your redux  state  and returns all the translation data in your redux store.   Arguments:      name  Type  Description      state  any  The localeReducer slice of your state.      Returns:     An object containing all your translation data.", 
            "title": "getTranslations(state)"
        }, 
        {
            "location": "/api/higher-order-component/", 
            "text": "localize(Component, [reducerName])\n\n\n\n  \nImportant\n\n  \nif your component is already using \nconnect\n then you should use the \ngetTranslate\n, and \ngetActiveLanguage\n selectors instead of \nlocalize\n.\n\n\n\n\n\nIf you have a component that just needs access to translations, and nothing else then you can use the \nlocalize\n higher-order function. When you pass your Component to localize it will automatically add \ntranslate\n and \ncurrentLanguage\n to props. \n\n\n Arguments: \n\n\n\n\n\n\n\n\nname\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nComponent\n\n\nReactComponent\n\n\nThe localeReducer slice of your state.\n\n\n\n\n\n\n[reducerName]\n\n\nstring\n\n\nIf you added localeReducer with \ncombineReducers\n then you will need to pass the reducerName to localize.\n\n\n\n\n\n\n\n\n Returns: \n \n\n\nA higher-order React component that adds \ntranslate\n and \ncurrentLanguage\n to props.\n\n\n Usage: \n\n\nconst Greeting = ({ translate, currentLanguage }) =\n (\n  \nspan\n\n    \nh1\nlanguageCode: { currentLanguage }\n/h1\n\n    \nh2\n{ translate('greeting', { name: 'Testy McTest' }) }\n/h2\n\n  \n/span\n\n);\nexport default localize(Greeting, 'locale');", 
            "title": "Higher Order Component"
        }, 
        {
            "location": "/api/higher-order-component/#localizecomponent-reducername", 
            "text": "Important \n   if your component is already using  connect  then you should use the  getTranslate , and  getActiveLanguage  selectors instead of  localize .   If you have a component that just needs access to translations, and nothing else then you can use the  localize  higher-order function. When you pass your Component to localize it will automatically add  translate  and  currentLanguage  to props.    Arguments:      name  Type  Description      Component  ReactComponent  The localeReducer slice of your state.    [reducerName]  string  If you added localeReducer with  combineReducers  then you will need to pass the reducerName to localize.      Returns:     A higher-order React component that adds  translate  and  currentLanguage  to props.   Usage:   const Greeting = ({ translate, currentLanguage }) =  (\n   span \n     h1 languageCode: { currentLanguage } /h1 \n     h2 { translate('greeting', { name: 'Testy McTest' }) } /h2 \n   /span \n);\nexport default localize(Greeting, 'locale');", 
            "title": "localize(Component, [reducerName])"
        }
    ]
}